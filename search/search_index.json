{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dcm2bids Your friendly DICOM converter. dcm2bids reorganises NIfTI files using dcm2niix into the Brain Imaging Data Structure (BIDS). Scope dcm2bids is a community-centered project. It aims to be a friendly, easy-to-use tool to convert your dicoms. Our main goal is to make the dicom to BIDS conversion as effortless as possible. Even if in the near future more advanced features will be added, we'll keep the focus on your day to day use case without complicating anything. That's the promise of the dcm2bids project. Documentation Please take a look at the documentation to: Learn about bids with some dataset examples Install dcm2bids Follow the tutorial Seek for more advanced usage Issues and Questions We work hard to make sure dcm2bids is robust and we welcome comments and questions to make sure it meets your use case! Here's our preferred workflow: If you have a usage question , we encourage you to post your question on Neurostars with dcm2bids as an optional tag. The tag is really important because Neurostars will notify the dcm2bids team only if the tag is present. Neurostars is a question and answer forum for neuroscience researchers, infrastructure providers and software developers, and free to access. Before posting your question, you may want to first browse through questions that were tagged with the dcm2bids tag . If your question persists, feel free to comment on previous questions or ask your own question. If you think you've found a bug , please open an issue on our repository . To do this, you'll need a GitHub account. See our contributing guide for more details.","title":"Home"},{"location":"#dcm2bids","text":"Your friendly DICOM converter. dcm2bids reorganises NIfTI files using dcm2niix into the Brain Imaging Data Structure (BIDS).","title":"dcm2bids"},{"location":"#scope","text":"dcm2bids is a community-centered project. It aims to be a friendly, easy-to-use tool to convert your dicoms. Our main goal is to make the dicom to BIDS conversion as effortless as possible. Even if in the near future more advanced features will be added, we'll keep the focus on your day to day use case without complicating anything. That's the promise of the dcm2bids project.","title":"Scope"},{"location":"#documentation","text":"Please take a look at the documentation to: Learn about bids with some dataset examples Install dcm2bids Follow the tutorial Seek for more advanced usage","title":"Documentation"},{"location":"#issues-and-questions","text":"We work hard to make sure dcm2bids is robust and we welcome comments and questions to make sure it meets your use case! Here's our preferred workflow: If you have a usage question , we encourage you to post your question on Neurostars with dcm2bids as an optional tag. The tag is really important because Neurostars will notify the dcm2bids team only if the tag is present. Neurostars is a question and answer forum for neuroscience researchers, infrastructure providers and software developers, and free to access. Before posting your question, you may want to first browse through questions that were tagged with the dcm2bids tag . If your question persists, feel free to comment on previous questions or ask your own question. If you think you've found a bug , please open an issue on our repository . To do this, you'll need a GitHub account. See our contributing guide for more details.","title":"Issues and Questions"},{"location":"CHANGELOG/","text":"CHANGELOG 2.1.6 - 2021-02-16 New Containers Fix pypi package 2.1.5 - 2021-01-04 Add possibility to be not case sensitive Fix issue 34: dcm2bids not ordering runs chronologically 2.1.4 - 2019-04-04 Add a tutorial to the documentation Update BIDS version in dcm2bids_scaffold Bug fix when intendedFor was equal to 0 Restructuring of the documentation and add version description 2.1.3 - 2019-04-02 dicom_dir can be a list or str 2.1.2 - 2019-04-01 Add documentation with mkdocs Bug fix in dcm2niix_version 2.1.1 - 2019-03-29 Bug fix 2.1.0 - 2019-03-28 Checking if a new version of dcm2bids or dcm2niix is available on github dcm2niix output is now log to file as debug Add dcm2bids version to sidecars intendedFor option can also be a list 2.0.0 - 2019-03-10 The anonymizer option no longer exists from the script dcm2bids. It is still possible to deface the anatomical nifti images using the \"defaceTpl\" key in the congifuration file. Acquisitions are now sorted using the sidecar data instead of only the sidecar filename. The default behaviour is to sort by SeriesNumber then by AcquisitionTime then by the SidecarFilename . You can change this behaviour setting the key \"compKeys\" inside the configuration file. Add an option to use re for more flexibility for matching criteria. Set the key \"searchMethod\" to \"re\" in the config file. fnmatch is still the default. Design fix in matching with list in the sidecar. Sidecar modification using \"sidecarChanges\" in the configuration file. intendedFor option for fieldmap in the configuration file log improvement major code refactoring add docstrings add tests with pytest 1.1.8 - 2018-02-02 Add dcm2bids as runscript inside Singularity Remove logger from dcm2bids_helper 1.1.7 - 2018-02-01 1.1.6 - 2018-02-01 1.1.4 - 2017-11-09 1.1.3 - 2017-11-09 1.1.2 - 2017-11-03 1.0.1 - 2017-11-01","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"CHANGELOG"},{"location":"CHANGELOG/#216-2021-02-16","text":"New Containers Fix pypi package","title":"2.1.6 - 2021-02-16"},{"location":"CHANGELOG/#215-2021-01-04","text":"Add possibility to be not case sensitive Fix issue 34: dcm2bids not ordering runs chronologically","title":"2.1.5 - 2021-01-04"},{"location":"CHANGELOG/#214-2019-04-04","text":"Add a tutorial to the documentation Update BIDS version in dcm2bids_scaffold Bug fix when intendedFor was equal to 0 Restructuring of the documentation and add version description","title":"2.1.4 - 2019-04-04"},{"location":"CHANGELOG/#213-2019-04-02","text":"dicom_dir can be a list or str","title":"2.1.3 - 2019-04-02"},{"location":"CHANGELOG/#212-2019-04-01","text":"Add documentation with mkdocs Bug fix in dcm2niix_version","title":"2.1.2 - 2019-04-01"},{"location":"CHANGELOG/#211-2019-03-29","text":"Bug fix","title":"2.1.1 - 2019-03-29"},{"location":"CHANGELOG/#210-2019-03-28","text":"Checking if a new version of dcm2bids or dcm2niix is available on github dcm2niix output is now log to file as debug Add dcm2bids version to sidecars intendedFor option can also be a list","title":"2.1.0 - 2019-03-28"},{"location":"CHANGELOG/#200-2019-03-10","text":"The anonymizer option no longer exists from the script dcm2bids. It is still possible to deface the anatomical nifti images using the \"defaceTpl\" key in the congifuration file. Acquisitions are now sorted using the sidecar data instead of only the sidecar filename. The default behaviour is to sort by SeriesNumber then by AcquisitionTime then by the SidecarFilename . You can change this behaviour setting the key \"compKeys\" inside the configuration file. Add an option to use re for more flexibility for matching criteria. Set the key \"searchMethod\" to \"re\" in the config file. fnmatch is still the default. Design fix in matching with list in the sidecar. Sidecar modification using \"sidecarChanges\" in the configuration file. intendedFor option for fieldmap in the configuration file log improvement major code refactoring add docstrings add tests with pytest","title":"2.0.0 - 2019-03-10"},{"location":"CHANGELOG/#118-2018-02-02","text":"Add dcm2bids as runscript inside Singularity Remove logger from dcm2bids_helper","title":"1.1.8 - 2018-02-02"},{"location":"CHANGELOG/#117-2018-02-01","text":"","title":"1.1.7 - 2018-02-01"},{"location":"CHANGELOG/#116-2018-02-01","text":"","title":"1.1.6 - 2018-02-01"},{"location":"CHANGELOG/#114-2017-11-09","text":"","title":"1.1.4 - 2017-11-09"},{"location":"CHANGELOG/#113-2017-11-09","text":"","title":"1.1.3 - 2017-11-09"},{"location":"CHANGELOG/#112-2017-11-03","text":"","title":"1.1.2 - 2017-11-03"},{"location":"CHANGELOG/#101-2017-11-01","text":"","title":"1.0.1 - 2017-11-01"},{"location":"CODE_OF_CONDUCT/","text":"Code of Conduct Each of us as a member of the dcm2bids community we ensure that every contributors enjoy their time contributing and helping people. Accordingly, everyone who participates in the development in any way possible is expected to show respect, courtesy to other community members including end-users who are seeking help on Neurostars or on GitHub . We also encourage everybody regardless of age, gender identity, level of experience, native langage, race or religion to be involved in the project. We pledge to make participation in the dcm2bids project an harassment-free experience for everyone. Our standards We commit to promote any behavior that contributes to create a positive environment including: Using welcoming and inclusive language; Being respectful; Show empathy towards everybody; Focusing on what is best for the community. We do NOT tolerate harassment or inappropriate behavior in the dcm2bids community. Our responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within our online GitHub repository and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting Arnaud Bor\u00e9 at arnaud.bore@criugm.qc.ca . Confidentiality will be respected in reporting. As the first interim Benevolent Dictator for Life (BDFL) , Arnaud Bor\u00e9 can take any action he deems appropriate for the safety of the dcm2bids community, including but not limited to: facilitating a conversation between the two parties involved in the violation of the code of conduct; requesting a contributor apologize for their behavior; asking a contributor or multiple contributors to enter a cooling off period that puts a time-limited pause on a particular discussion topic; asking a contributor to no longer participate in the development of dcm2bids . Attribution This Code of Conduct was adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html as well as Code of Conduct from the tedana and STEMMRoleModels projects.","title":"Code of conduct"},{"location":"CODE_OF_CONDUCT/#code-of-conduct","text":"Each of us as a member of the dcm2bids community we ensure that every contributors enjoy their time contributing and helping people. Accordingly, everyone who participates in the development in any way possible is expected to show respect, courtesy to other community members including end-users who are seeking help on Neurostars or on GitHub . We also encourage everybody regardless of age, gender identity, level of experience, native langage, race or religion to be involved in the project. We pledge to make participation in the dcm2bids project an harassment-free experience for everyone.","title":"Code of Conduct"},{"location":"CODE_OF_CONDUCT/#our-standards","text":"We commit to promote any behavior that contributes to create a positive environment including: Using welcoming and inclusive language; Being respectful; Show empathy towards everybody; Focusing on what is best for the community. We do NOT tolerate harassment or inappropriate behavior in the dcm2bids community.","title":"Our standards"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our responsibilities"},{"location":"CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies both within our online GitHub repository and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting Arnaud Bor\u00e9 at arnaud.bore@criugm.qc.ca . Confidentiality will be respected in reporting. As the first interim Benevolent Dictator for Life (BDFL) , Arnaud Bor\u00e9 can take any action he deems appropriate for the safety of the dcm2bids community, including but not limited to: facilitating a conversation between the two parties involved in the violation of the code of conduct; requesting a contributor apologize for their behavior; asking a contributor or multiple contributors to enter a cooling off period that puts a time-limited pause on a particular discussion topic; asking a contributor to no longer participate in the development of dcm2bids .","title":"Enforcement"},{"location":"CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct was adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html as well as Code of Conduct from the tedana and STEMMRoleModels projects.","title":"Attribution"},{"location":"CONTRIBUTING/","text":"Contributing to dcm2bids Welcome to the dcm2bids repository and thank you for thinking about contributing! This document has been written in such a way you feel at ease to find your way on how you can make a difference for the dcm2bids community. We tried to cover as much as possible in few words possible. If you have any questions don't hesitate to share them in the section below. There are multiple ways to be helpful to the dcm2bids community. If you already know what you are looking for, you can select one of the section below: Contributing to dcm2bids Welcome Contributing through Neurostars Contributing through GitHub Recommended workflow Open an issue or choose one to fix Fork the dcm2bids repository Test your branch Check list Submit and tag your pull request Recognizing your contribution Thank you! If you don't know where or how to get started, keep on reading below. Welcome dcm2bids is a small project started in 2017 by Christophe Bedetti ( @cbedetti ). In 2021, we have started a new initiative and we're excited to have you join! You can introduce yourself on our Welcome to Dcm2Bids Discussion and tell us how you would like to contribute in the dcm2bids community. Let us know what your interests are and we will help you find an issue to contribute to if you haven't already spotted one yet. Most of our discussions will take place on open issues and in the newly created GitHub Discussions . Thanks so much! As a reminder, we expect all contributions to dcm2bids to adhere to our Code of Conduct . Contributing through Neurostars The dcm2bids community highlight all contributions to dcm2bids . Helping users on Neurostars forum is one of them. Neurostars has a dcm2bids tag that helps us following any question regarding the project. You can ask Neurostars to notify you when a new message tagged with dcm2bids has been posted. If you know the answer, you can reply following our code of conduct . How to receive email notifications from Neurostars If you want to receive email notifications, you have to go set your settings accordingly on Neurostars. The procedure below will get you to this (personalized) URL: https://neurostars.org/u/ YOURUSERNAME /preferences/tags : Click on your picture in the top right corner Click on the \ud83d\udc64 (user) icon Click on \u2699\ufe0f Preferences Click on Notifications Click on Tags We recommend to add dcm2bids to the Watched section, but you can add it to any section that fits your need. Contributing through GitHub Git is a really useful tool for version control . GitHub sits on top of git and supports collaborative and distributed working. Before you start you'll need to set up a free GitHub account and sign in. You can sign up through this link and then interact on our repository at https://github.io/UNFmontreal/Dcm2Bids . You'll use Markdown to discuss on GitHub. You can think of Markdown as a few little symbols around your text that will allow GitHub to render the text with a little bit of formatting. For example you can write words as bold ( **bold** ), or in italics ( *italics* ), or as a link ( [link](https://youtu.be/dQw4w9WgXcQ) ) to another webpage. Did you know? Most software documentation websites are written in Markdown. Even the dcm2bids documentation website is written in Markdown! GitHub has a helpful guide to get you started with writing and formatting Markdown . Recommended workflow We will be excited when you'll suggest a new PR to fix, enhance or develop dcm2bids . In order to make this as fluid as possible we recommend to follow this workflow: Open an issue or choose one to fix Issues are individual pieces of work that need to be completed to move the project forwards. Before starting to work on a new pull request we highly recommend you open an issue to explain what you want to do and how it echoes a specific demand from the community. Keep in mind the scope of the dcm2bids project. If you have more an inquiry or suggestion to make than a bug to report, we encourage you to start a conversation in the Discussions section . A general guideline: if you find yourself tempted to write a great big issue that is difficult to describe as one unit of work, please consider splitting it into two or more. Moreover, it will be interesting to see how others approach your issue and give their opinion and maybe give you advice to find the best way to code it. Finally, it will prevent you to start working on something that is already in progress. The list of all labels is here and include: These issues contain a task that a member of the team has determined we need additional help with. If you feel that you can contribute to one of these issues, we especially encourage you to do so! These issues point to problems in the project. If you find new a bug, please give as much detail as possible in your issue, including steps to recreate the error. If you experience the same bug as one already listed, please add any additional information that you have as a comment. These issues are asking for enhancements to be added to the project. Please try to make sure that your enhancement is distinct from any others that have already been requested or implemented. If you find one that's similar but there are subtle differences please reference the other request in your issue. Fork the dcm2bids repository This way you'll be able to work on your own instance of dcm2bids . It will be a safe place where nothing can affect the main repository. Make sure your master branch is always up-to-date with dcm2bids' master branch. You can also follow these command lines. The first time you try to sync your fork , you may have to set the upstream branch : git remote add upstream https://github.com/UNFmontreal/Dcm2Bids.git git remote -v # Verify the new upstream repo appears. git checkout master git fetch upstream master git merge upstream/master Then create a new branch for each issue. Using a new branch allows you to follow the standard GitHub workflow when making changes. This guide provides a useful overview for this workflow. Please keep the name of your branch short and self explanatory. git checkout -b MYBRANCH Test your branch If you are proposing new features, you'll need to add new tests as well. In any case, you have to test your branch prior to submit your PR. If you have new code you will have to run pytest: pytest -v tests/test_dcm2bids.py dcm2bids project is following PEP8 convention whenever possible. You can check your code using this command line: flake8 FileIWantToCheck Regardless, when you open a Pull Request, we use Tox to run all unit and integration tests. If you have propose a PR about a modification on the documentation you can have a preview from an editor like Atom using CTRL+SHIFT+M . Check list Pull Request Checklist (For Fastest Review): [x] Check that all tests are passing (\"All tests passsed\") [x] Make sure you have docstrings for any new functions [x] Make sure that docstrings are updated for edited functions [x] Make sure you note any issues that will be closed by your PR [x] Add a clear description of the purpose of you PR Submit and tag your pull request When you submit a pull request we ask you to follow the tag specification. In order to simplify reviewers work, we ask you to use at least one of the following tags: [BRK] for changes which break existing builds or tests [DOC] for new or updated documentation [ENH] for enhancements [FIX] for bug fixes [TST] for new or updated tests [REF] for refactoring existing code [MAINT] for maintenance of code [WIP] for work in progress You can also combine the tags above, for example if you are updating both a test and the documentation: [TST, DOC]. Recognizing your contribution We welcome and recognize all contributions from documentation to testing to code development. You can see a list of current contributors in the README (kept up to date by the all contributors bot ). You can see here for instructions on how to use the bot. Thank you! You're amazing. \u2014 Based on contributing guidelines from the STEMMRoleModels and tedana projects.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-to-dcm2bids","text":"Welcome to the dcm2bids repository and thank you for thinking about contributing! This document has been written in such a way you feel at ease to find your way on how you can make a difference for the dcm2bids community. We tried to cover as much as possible in few words possible. If you have any questions don't hesitate to share them in the section below. There are multiple ways to be helpful to the dcm2bids community. If you already know what you are looking for, you can select one of the section below: Contributing to dcm2bids Welcome Contributing through Neurostars Contributing through GitHub Recommended workflow Open an issue or choose one to fix Fork the dcm2bids repository Test your branch Check list Submit and tag your pull request Recognizing your contribution Thank you! If you don't know where or how to get started, keep on reading below.","title":"Contributing to dcm2bids"},{"location":"CONTRIBUTING/#welcome","text":"dcm2bids is a small project started in 2017 by Christophe Bedetti ( @cbedetti ). In 2021, we have started a new initiative and we're excited to have you join! You can introduce yourself on our Welcome to Dcm2Bids Discussion and tell us how you would like to contribute in the dcm2bids community. Let us know what your interests are and we will help you find an issue to contribute to if you haven't already spotted one yet. Most of our discussions will take place on open issues and in the newly created GitHub Discussions . Thanks so much! As a reminder, we expect all contributions to dcm2bids to adhere to our Code of Conduct .","title":"Welcome"},{"location":"CONTRIBUTING/#contributing-through-neurostars","text":"The dcm2bids community highlight all contributions to dcm2bids . Helping users on Neurostars forum is one of them. Neurostars has a dcm2bids tag that helps us following any question regarding the project. You can ask Neurostars to notify you when a new message tagged with dcm2bids has been posted. If you know the answer, you can reply following our code of conduct . How to receive email notifications from Neurostars If you want to receive email notifications, you have to go set your settings accordingly on Neurostars. The procedure below will get you to this (personalized) URL: https://neurostars.org/u/ YOURUSERNAME /preferences/tags : Click on your picture in the top right corner Click on the \ud83d\udc64 (user) icon Click on \u2699\ufe0f Preferences Click on Notifications Click on Tags We recommend to add dcm2bids to the Watched section, but you can add it to any section that fits your need.","title":"Contributing through Neurostars"},{"location":"CONTRIBUTING/#contributing-through-github","text":"Git is a really useful tool for version control . GitHub sits on top of git and supports collaborative and distributed working. Before you start you'll need to set up a free GitHub account and sign in. You can sign up through this link and then interact on our repository at https://github.io/UNFmontreal/Dcm2Bids . You'll use Markdown to discuss on GitHub. You can think of Markdown as a few little symbols around your text that will allow GitHub to render the text with a little bit of formatting. For example you can write words as bold ( **bold** ), or in italics ( *italics* ), or as a link ( [link](https://youtu.be/dQw4w9WgXcQ) ) to another webpage. Did you know? Most software documentation websites are written in Markdown. Even the dcm2bids documentation website is written in Markdown! GitHub has a helpful guide to get you started with writing and formatting Markdown .","title":"Contributing through GitHub"},{"location":"CONTRIBUTING/#recommended-workflow","text":"We will be excited when you'll suggest a new PR to fix, enhance or develop dcm2bids . In order to make this as fluid as possible we recommend to follow this workflow:","title":"Recommended workflow"},{"location":"CONTRIBUTING/#open-an-issue-or-choose-one-to-fix","text":"Issues are individual pieces of work that need to be completed to move the project forwards. Before starting to work on a new pull request we highly recommend you open an issue to explain what you want to do and how it echoes a specific demand from the community. Keep in mind the scope of the dcm2bids project. If you have more an inquiry or suggestion to make than a bug to report, we encourage you to start a conversation in the Discussions section . A general guideline: if you find yourself tempted to write a great big issue that is difficult to describe as one unit of work, please consider splitting it into two or more. Moreover, it will be interesting to see how others approach your issue and give their opinion and maybe give you advice to find the best way to code it. Finally, it will prevent you to start working on something that is already in progress. The list of all labels is here and include: These issues contain a task that a member of the team has determined we need additional help with. If you feel that you can contribute to one of these issues, we especially encourage you to do so! These issues point to problems in the project. If you find new a bug, please give as much detail as possible in your issue, including steps to recreate the error. If you experience the same bug as one already listed, please add any additional information that you have as a comment. These issues are asking for enhancements to be added to the project. Please try to make sure that your enhancement is distinct from any others that have already been requested or implemented. If you find one that's similar but there are subtle differences please reference the other request in your issue.","title":"Open an issue or choose one to fix"},{"location":"CONTRIBUTING/#fork-the-dcm2bids-repository","text":"This way you'll be able to work on your own instance of dcm2bids . It will be a safe place where nothing can affect the main repository. Make sure your master branch is always up-to-date with dcm2bids' master branch. You can also follow these command lines. The first time you try to sync your fork , you may have to set the upstream branch : git remote add upstream https://github.com/UNFmontreal/Dcm2Bids.git git remote -v # Verify the new upstream repo appears. git checkout master git fetch upstream master git merge upstream/master Then create a new branch for each issue. Using a new branch allows you to follow the standard GitHub workflow when making changes. This guide provides a useful overview for this workflow. Please keep the name of your branch short and self explanatory. git checkout -b MYBRANCH","title":"Fork the dcm2bids repository"},{"location":"CONTRIBUTING/#test-your-branch","text":"If you are proposing new features, you'll need to add new tests as well. In any case, you have to test your branch prior to submit your PR. If you have new code you will have to run pytest: pytest -v tests/test_dcm2bids.py dcm2bids project is following PEP8 convention whenever possible. You can check your code using this command line: flake8 FileIWantToCheck Regardless, when you open a Pull Request, we use Tox to run all unit and integration tests. If you have propose a PR about a modification on the documentation you can have a preview from an editor like Atom using CTRL+SHIFT+M .","title":"Test your branch"},{"location":"CONTRIBUTING/#check-list","text":"Pull Request Checklist (For Fastest Review): [x] Check that all tests are passing (\"All tests passsed\") [x] Make sure you have docstrings for any new functions [x] Make sure that docstrings are updated for edited functions [x] Make sure you note any issues that will be closed by your PR [x] Add a clear description of the purpose of you PR","title":"Check list"},{"location":"CONTRIBUTING/#submit-and-tag-your-pull-request","text":"When you submit a pull request we ask you to follow the tag specification. In order to simplify reviewers work, we ask you to use at least one of the following tags: [BRK] for changes which break existing builds or tests [DOC] for new or updated documentation [ENH] for enhancements [FIX] for bug fixes [TST] for new or updated tests [REF] for refactoring existing code [MAINT] for maintenance of code [WIP] for work in progress You can also combine the tags above, for example if you are updating both a test and the documentation: [TST, DOC].","title":"Submit and tag your pull request"},{"location":"CONTRIBUTING/#recognizing-your-contribution","text":"We welcome and recognize all contributions from documentation to testing to code development. You can see a list of current contributors in the README (kept up to date by the all contributors bot ). You can see here for instructions on how to use the bot.","title":"Recognizing your contribution"},{"location":"CONTRIBUTING/#thank-you","text":"You're amazing. \u2014 Based on contributing guidelines from the STEMMRoleModels and tedana projects.","title":"Thank you!"},{"location":"docs/1-usage/","text":"Usage Introduction dcm2bids converts one session at a time. A session is all the acquisitions between the entry and exit of the participant in the scanner. You need to build a configuration file of your study to let dcm2bids associates your acquisitions through BIDS sidecar. Every study is different and this step needs a little bit of work. The scanner parameters should not change too much for one study (several MRI sessions), so a few configuration files should work. BIDS sidecar 1 files are JSON files with meta informations about the acquisition. dcm2niix (DICOM to NIfTI converter used by dcm2bids) creates automatically one BIDS sidecar for each NIfTI file. dcm2bids configuration file uses also the JSON format. One example is provided in the example folder on the github repository. It is recommended to use an editor with syntax highlighting to build a correct JSON file. Here is an online one. Command Line Interface (CLI) How to launch dcm2bids when you have build your configuration file ? First cd in your BIDS directory. dcm2bids -d DICOM_DIR -p PARTICIPANT_ID -c CONFIG_FILE If your participant have a session ID: dcm2bids -d DICOM_DIR -p PARTICIPANT_ID -s SESSION_ID -c CONFIG_FILE dcm2bids creates log files inside tmp_dcm2bids/log See dcm2bids -h or dcm2bids --help to show the help message that contains more information. Output dcm2bids creates a sub-<PARTICIPANT_ID> directory in the output directory (by default the folder where the script is launched). Sidecars with one matching description will be convert to BIDS. If a file already exists, dcm2bids won't overwrite it. You should use the --clobber option to overwrite files. If a description matches several sidecars, dcm2bids will add automatically the custom label run- to the filename. Sidecars with no or more than one matching descriptions are kept in tmp_dcm2bids directory. Users can review these mismatches to change the configuration file accordingly. Tools Helper dcm2bids_helper -d DICOM_DIR [ -o OUTPUT_DIR ] To build the configuration file, you need to have a example of the sidecars. You can use dcm2bids_helper with the DICOMs of one participant. It will launch dcm2niix and save the result inside the tmp_dcm2bids/helper of the output directory. Scaffold dcm2bids_scaffold [ -o OUTPUT_DIR ] Create basic BIDS files and directories in the output directory (by default folder where the script is launched). Containers You can also use all the tools through docker or singularity images. Docker docker pull unfmontreal/dcm2bids:latest Singularity singularity pull dcm2bids_latest.sif docker://unfmontreal/dcm2bids:latest For each acquisition, dcm2niix creates an associated .json file, containing information from the dicom header. These are known as sidecars . These are the sidecars dcm2bids uses to filter the groups of acquisitions. To define this filtering you will probably need to review these sidecars. You can generate all the sidecars for an individual participant using dcm2bids_helper . \u21a9","title":"1. Usage"},{"location":"docs/1-usage/#usage","text":"","title":"Usage"},{"location":"docs/1-usage/#introduction","text":"dcm2bids converts one session at a time. A session is all the acquisitions between the entry and exit of the participant in the scanner. You need to build a configuration file of your study to let dcm2bids associates your acquisitions through BIDS sidecar. Every study is different and this step needs a little bit of work. The scanner parameters should not change too much for one study (several MRI sessions), so a few configuration files should work. BIDS sidecar 1 files are JSON files with meta informations about the acquisition. dcm2niix (DICOM to NIfTI converter used by dcm2bids) creates automatically one BIDS sidecar for each NIfTI file. dcm2bids configuration file uses also the JSON format. One example is provided in the example folder on the github repository. It is recommended to use an editor with syntax highlighting to build a correct JSON file. Here is an online one.","title":"Introduction"},{"location":"docs/1-usage/#command-line-interface-cli","text":"How to launch dcm2bids when you have build your configuration file ? First cd in your BIDS directory. dcm2bids -d DICOM_DIR -p PARTICIPANT_ID -c CONFIG_FILE If your participant have a session ID: dcm2bids -d DICOM_DIR -p PARTICIPANT_ID -s SESSION_ID -c CONFIG_FILE dcm2bids creates log files inside tmp_dcm2bids/log See dcm2bids -h or dcm2bids --help to show the help message that contains more information.","title":"Command Line Interface (CLI)"},{"location":"docs/1-usage/#output","text":"dcm2bids creates a sub-<PARTICIPANT_ID> directory in the output directory (by default the folder where the script is launched). Sidecars with one matching description will be convert to BIDS. If a file already exists, dcm2bids won't overwrite it. You should use the --clobber option to overwrite files. If a description matches several sidecars, dcm2bids will add automatically the custom label run- to the filename. Sidecars with no or more than one matching descriptions are kept in tmp_dcm2bids directory. Users can review these mismatches to change the configuration file accordingly.","title":"Output"},{"location":"docs/1-usage/#tools","text":"Helper dcm2bids_helper -d DICOM_DIR [ -o OUTPUT_DIR ] To build the configuration file, you need to have a example of the sidecars. You can use dcm2bids_helper with the DICOMs of one participant. It will launch dcm2niix and save the result inside the tmp_dcm2bids/helper of the output directory. Scaffold dcm2bids_scaffold [ -o OUTPUT_DIR ] Create basic BIDS files and directories in the output directory (by default folder where the script is launched).","title":"Tools"},{"location":"docs/1-usage/#containers","text":"You can also use all the tools through docker or singularity images. Docker docker pull unfmontreal/dcm2bids:latest Singularity singularity pull dcm2bids_latest.sif docker://unfmontreal/dcm2bids:latest For each acquisition, dcm2niix creates an associated .json file, containing information from the dicom header. These are known as sidecars . These are the sidecars dcm2bids uses to filter the groups of acquisitions. To define this filtering you will probably need to review these sidecars. You can generate all the sidecars for an individual participant using dcm2bids_helper . \u21a9","title":"Containers"},{"location":"docs/2-tutorial/","text":"Tutorial Setup Create a new folder for this tutorial. mkdir dcm2bids-tutorial cd dcm2bids-tutorial You can skip this part and go to the next section if dcm2niix and dcm2bids are already installed. The tutorial suppose that conda is installed and correctly setup on your computer. It is the easiest way to install dcm2bids and its dependencies on any OS. You should know that this is not the best way because conda does not always have the last version of dcm2niix. Create a new file environment.yml with your favorite text editor with this content: name : dcm2bids channels : - conda-forge dependencies : - dcm2niix - dcm2bids - pip Finaly, create a new conda environment to install dcm2bids: conda env create -f environment.yml source activate dcm2bids We should have access to dcm2bids now. Test it with dcm2bids --help . Scaffolding We can now run the command dcm2bids_scaffold . This gives us several generics folders and files. We can have a look at these files and consult the BIDS specification for more information. One of the created folders is named sourcedata , this is the folder to put your DICOMs Downloading test data For this tutorial, we will use DICOMs from neurolabusc on github. Go to : https://github.com/neurolabusc/dcm_qa_nih and click on the Clone or download button to download as ZIP. Move the zip file to the sourcedata folder and unzip it. Here is how to do it in the terminal but we could do it the way we want. mv ~/Downloads/dcm_qa_nih-master.zip sourcedata/ cd sourcedata unzip dcm_qa_nih-master.zip cd .. We should have now a dcm_qa_nih-master folder inside sourcedata. DICOM to NIfTI conversion dcm2bids_helper -d sourcedata/dcm_qa_nih-master/In/ This command will convert the DICOMs files to NIfTI files and save them inside tmp_dcm2bids/helper/ . We should see a list of compressed NIfTI files ( nii.gz ) with their resective sidecar files ( .json ). For this tutorial, we will only be interested in three acquisitions : 004_In_Axial_EPI-FMRI_(Interleaved_I_to_S)_20180918114023.nii.gz 004_In_EPI_PE=PA_20180918121230.nii.gz 003_In_EPI_PE=AP_20180918121230.nii.gz The first will be our resting state fMRI, the second and third our fieldmap EPI. When you will do it with your DICOMs, you should do it with a typical session of one of your participants. Building the configuration file Now we will create a configuration file called dcm2bids_config.json (this is just an example, it could be whatever we want) in the code/ folder. Use any text editor to create the file with the contents: { \"descriptions\" : [] } For example, with our resting state fMRI we see in its sidecar that the field \"SeriesDescription\" is equal to \"Axial_EPI-FMRI_(Interleaved_I_to_S)\" . We can open 004_In_Axial_EPI-FMRI_(Interleaved_I_to_S)_20180918114023.json to verify that. This value could be match with a pattern \"Axial_EPI-FMRI*\" . Unfortunately, this criteria is not enough and could match other files. See 006_In_Axial_EPI-FMRI_(Interleaved_S_to_I)_20180918114023.json . In this case we could add another criteria to match the acquisition by the filename of the sidecar with the pattern \"*Interleaved_I_to_S*\" . With all this information we could then update our configuration file. { \"descriptions\" : [ { \"dataType\" : \"func\" , \"modalityLabel\" : \"bold\" , \"customLabels\" : \"task-rest\" , \"criteria\" : { \"SeriesDescription\" : \"Axial_EPI-FMRI*\" , \"SidecarFilename\" : \"*Interleaved_I_to_S*\" } } ] } For the two fieldmaps, we can see that with patterns of \"*EPI_PE=AP*\" or \"*EPI_PE=PA*\" on the filename is enough to match the correct acquisition. We could then update our configuration file. { \"descriptions\" : [ { \"dataType\" : \"func\" , \"modalityLabel\" : \"bold\" , \"customLabels\" : \"task-rest\" , \"criteria\" : { \"SeriesDescription\" : \"Axial_EPI-FMRI*\" , \"SidecarFilename\" : \"*Interleaved_I_to_S*\" } }, { \"dataType\" : \"fmap\" , \"modalityLabel\" : \"epi\" , \"customLabels\" : \"dir-AP\" , \"criteria\" : { \"SidecarFilename\" : \"*EPI_PE=AP*\" }, \"intendedFor\" : 0 }, { \"dataType\" : \"fmap\" , \"modalityLabel\" : \"epi\" , \"customLabels\" : \"dir-PA\" , \"criteria\" : { \"SidecarFilename\" : \"*EPI_PE=PA*\" }, \"intendedFor\" : 0 } ] } For fieldmap, we added an \"intendedFor\" field to show that these fieldmaps should be use with our fMRI acquisition. Have a look at the explanation of intendedFor in the documentation or in the BIDS specification . Running dcm2bids We can now run dcm2bids: dcm2bids -d sourcedata/dcm_qa_nih-master/In/ -p ID01 -c code/dcm2bids_config.json A bunch of information is print to the terminal and we can verify that the data are now in BIDS. user@pc:data/$ ls sub-ID01/* sub-ID01/fmap: sub-ID01_dir-AP_epi.json sub-ID01_dir-AP_epi.nii.gz sub-ID01_dir-PA_epi.json sub-ID01_dir-PA_epi.nii.gz sub-ID01/func: sub-ID01_task-rest_bold.json sub-ID01_task-rest_bold.nii.gz Files that were not grabbed stay in a temporary folder tmp_dcm2bids/sub-{participant_id} . In our case : tmp_dcm2bids/sub-ID01 . Have a look at dcm2bids --help or the other pages of the documentation for more information.","title":"2. Tutorial"},{"location":"docs/2-tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"docs/2-tutorial/#setup","text":"Create a new folder for this tutorial. mkdir dcm2bids-tutorial cd dcm2bids-tutorial You can skip this part and go to the next section if dcm2niix and dcm2bids are already installed. The tutorial suppose that conda is installed and correctly setup on your computer. It is the easiest way to install dcm2bids and its dependencies on any OS. You should know that this is not the best way because conda does not always have the last version of dcm2niix. Create a new file environment.yml with your favorite text editor with this content: name : dcm2bids channels : - conda-forge dependencies : - dcm2niix - dcm2bids - pip Finaly, create a new conda environment to install dcm2bids: conda env create -f environment.yml source activate dcm2bids We should have access to dcm2bids now. Test it with dcm2bids --help .","title":"Setup"},{"location":"docs/2-tutorial/#scaffolding","text":"We can now run the command dcm2bids_scaffold . This gives us several generics folders and files. We can have a look at these files and consult the BIDS specification for more information. One of the created folders is named sourcedata , this is the folder to put your DICOMs","title":"Scaffolding"},{"location":"docs/2-tutorial/#downloading-test-data","text":"For this tutorial, we will use DICOMs from neurolabusc on github. Go to : https://github.com/neurolabusc/dcm_qa_nih and click on the Clone or download button to download as ZIP. Move the zip file to the sourcedata folder and unzip it. Here is how to do it in the terminal but we could do it the way we want. mv ~/Downloads/dcm_qa_nih-master.zip sourcedata/ cd sourcedata unzip dcm_qa_nih-master.zip cd .. We should have now a dcm_qa_nih-master folder inside sourcedata.","title":"Downloading test data"},{"location":"docs/2-tutorial/#dicom-to-nifti-conversion","text":"dcm2bids_helper -d sourcedata/dcm_qa_nih-master/In/ This command will convert the DICOMs files to NIfTI files and save them inside tmp_dcm2bids/helper/ . We should see a list of compressed NIfTI files ( nii.gz ) with their resective sidecar files ( .json ). For this tutorial, we will only be interested in three acquisitions : 004_In_Axial_EPI-FMRI_(Interleaved_I_to_S)_20180918114023.nii.gz 004_In_EPI_PE=PA_20180918121230.nii.gz 003_In_EPI_PE=AP_20180918121230.nii.gz The first will be our resting state fMRI, the second and third our fieldmap EPI. When you will do it with your DICOMs, you should do it with a typical session of one of your participants.","title":"DICOM to NIfTI conversion"},{"location":"docs/2-tutorial/#building-the-configuration-file","text":"Now we will create a configuration file called dcm2bids_config.json (this is just an example, it could be whatever we want) in the code/ folder. Use any text editor to create the file with the contents: { \"descriptions\" : [] } For example, with our resting state fMRI we see in its sidecar that the field \"SeriesDescription\" is equal to \"Axial_EPI-FMRI_(Interleaved_I_to_S)\" . We can open 004_In_Axial_EPI-FMRI_(Interleaved_I_to_S)_20180918114023.json to verify that. This value could be match with a pattern \"Axial_EPI-FMRI*\" . Unfortunately, this criteria is not enough and could match other files. See 006_In_Axial_EPI-FMRI_(Interleaved_S_to_I)_20180918114023.json . In this case we could add another criteria to match the acquisition by the filename of the sidecar with the pattern \"*Interleaved_I_to_S*\" . With all this information we could then update our configuration file. { \"descriptions\" : [ { \"dataType\" : \"func\" , \"modalityLabel\" : \"bold\" , \"customLabels\" : \"task-rest\" , \"criteria\" : { \"SeriesDescription\" : \"Axial_EPI-FMRI*\" , \"SidecarFilename\" : \"*Interleaved_I_to_S*\" } } ] } For the two fieldmaps, we can see that with patterns of \"*EPI_PE=AP*\" or \"*EPI_PE=PA*\" on the filename is enough to match the correct acquisition. We could then update our configuration file. { \"descriptions\" : [ { \"dataType\" : \"func\" , \"modalityLabel\" : \"bold\" , \"customLabels\" : \"task-rest\" , \"criteria\" : { \"SeriesDescription\" : \"Axial_EPI-FMRI*\" , \"SidecarFilename\" : \"*Interleaved_I_to_S*\" } }, { \"dataType\" : \"fmap\" , \"modalityLabel\" : \"epi\" , \"customLabels\" : \"dir-AP\" , \"criteria\" : { \"SidecarFilename\" : \"*EPI_PE=AP*\" }, \"intendedFor\" : 0 }, { \"dataType\" : \"fmap\" , \"modalityLabel\" : \"epi\" , \"customLabels\" : \"dir-PA\" , \"criteria\" : { \"SidecarFilename\" : \"*EPI_PE=PA*\" }, \"intendedFor\" : 0 } ] } For fieldmap, we added an \"intendedFor\" field to show that these fieldmaps should be use with our fMRI acquisition. Have a look at the explanation of intendedFor in the documentation or in the BIDS specification .","title":"Building the configuration file"},{"location":"docs/2-tutorial/#running-dcm2bids","text":"We can now run dcm2bids: dcm2bids -d sourcedata/dcm_qa_nih-master/In/ -p ID01 -c code/dcm2bids_config.json A bunch of information is print to the terminal and we can verify that the data are now in BIDS. user@pc:data/$ ls sub-ID01/* sub-ID01/fmap: sub-ID01_dir-AP_epi.json sub-ID01_dir-AP_epi.nii.gz sub-ID01_dir-PA_epi.json sub-ID01_dir-PA_epi.nii.gz sub-ID01/func: sub-ID01_task-rest_bold.json sub-ID01_task-rest_bold.nii.gz Files that were not grabbed stay in a temporary folder tmp_dcm2bids/sub-{participant_id} . In our case : tmp_dcm2bids/sub-ID01 . Have a look at dcm2bids --help or the other pages of the documentation for more information.","title":"Running dcm2bids"},{"location":"docs/3-configuration/","text":"Configuration file Configuration file example { \"descriptions\" : [ { \"dataType\" : \"func\" , \"modalityLabel\" : \"bold\" , \"customLabels\" : \"task-rest\" , \"criteria\" : { \"SidecarFilename\" : \"006*\" , \"ImageType\" : [ \"ORIG*\" , \"PRIMARY\" , \"M\" , \"ND\" , \"MOSAIC\" ] } }, { \"dataType\" : \"anat\" , \"modalityLabel\" : \"T2w\" , \"criteria\" : { \"SeriesDescription\" : \"*T2*\" , \"EchoTime\" : 0.1 }, \"sidecarChanges\" : { \"ProtocolName\" : \"T2\" } }, { \"dataType\" : \"fmap\" , \"modalityLabel\" : \"fmap\" , \"intendedFor\" : 0 , \"criteria\" : { \"ProtocolName\" : \"*field_mapping*\" } } ] } The descriptions field is a list of descriptions, each describing some acquisition. In this example, the configuration describes three acquisitions, a T2 weighted, resting state fMRI and a fieldmap. Each description tells dcm2bids how to group a set of acquisitions and how to label them. In this config file, Dcm2Bids is being told to collect files containing { \"SeriesDescription\" : \"AXIAL_T2_SPACE\" , \"EchoTime\" : 0.1 } in their sidecars 1 and label them as anat , T2w type images. criteria dcm2bids will try to match the sidecars 1 of dcm2niix to the descriptions of the configuration file. The values you enter inside the criteria dictionary are patterns that will be compared to the corresponding key of the sidecar. The pattern matching is shell-style. It's possible to use wildcard * , single character ? etc ... Please have a look at the GNU documentation to know more. For example, in the second description, the pattern *T2* will be compared to the value of SeriesDescription of a sidecar. AXIAL_T2_SPACE will be a match, AXIAL_T1 won't. dcm2bids has a SidecarFilename key, as in the first description, if you prefer to also match with the filename of the sidecar. You can enter several criteria. All criteria must match for a description to be linked to a sidecar. dataType It is a mandatory field. Here is a definition from bids v1.2.0 : Data type - a functional group of different types of data. In BIDS we define six data types: func (task based and resting state functional MRI), dwi (diffusion weighted imaging), fmap (field inhomogeneity mapping data such as field maps), anat (structural imaging such as T1, T2, etc.), meg (magnetoencephalography), beh (behavioral). modalityLabel It is a mandatory field. It describes the modality of the acquisition like T1w , T2w or dwi , bold . customLabels It is an optional field. For some acquisitions, you need to add information in the file name. For resting state fMRI, it is usually task-rest . To know more on how to set these fields, read the BIDS specifications . For a longer example of a Dcm2Bids config json, see here . sidecarChanges Optional field to change or add information in a sidecar. intendedFor Optional field to add an IntendedFor entry in the sidecar of a fieldmap. Just put the index or a list of indices of the description(s) that's intended for. Python index begins at 0 so in the example, 0 means it is intended for task-rest_bold . For each acquisition, dcm2niix creates an associated .json file, containing information from the dicom header. These are known as sidecars . These are the sidecars dcm2bids uses to filter the groups of acquisitions. To define this filtering you will probably need to review these sidecars. You can generate all the sidecars for an individual participant using dcm2bids_helper . \u21a9 \u21a9","title":"3. Configuration"},{"location":"docs/3-configuration/#configuration-file","text":"","title":"Configuration file"},{"location":"docs/3-configuration/#configuration-file-example","text":"{ \"descriptions\" : [ { \"dataType\" : \"func\" , \"modalityLabel\" : \"bold\" , \"customLabels\" : \"task-rest\" , \"criteria\" : { \"SidecarFilename\" : \"006*\" , \"ImageType\" : [ \"ORIG*\" , \"PRIMARY\" , \"M\" , \"ND\" , \"MOSAIC\" ] } }, { \"dataType\" : \"anat\" , \"modalityLabel\" : \"T2w\" , \"criteria\" : { \"SeriesDescription\" : \"*T2*\" , \"EchoTime\" : 0.1 }, \"sidecarChanges\" : { \"ProtocolName\" : \"T2\" } }, { \"dataType\" : \"fmap\" , \"modalityLabel\" : \"fmap\" , \"intendedFor\" : 0 , \"criteria\" : { \"ProtocolName\" : \"*field_mapping*\" } } ] } The descriptions field is a list of descriptions, each describing some acquisition. In this example, the configuration describes three acquisitions, a T2 weighted, resting state fMRI and a fieldmap. Each description tells dcm2bids how to group a set of acquisitions and how to label them. In this config file, Dcm2Bids is being told to collect files containing { \"SeriesDescription\" : \"AXIAL_T2_SPACE\" , \"EchoTime\" : 0.1 } in their sidecars 1 and label them as anat , T2w type images.","title":"Configuration file example"},{"location":"docs/3-configuration/#criteria","text":"dcm2bids will try to match the sidecars 1 of dcm2niix to the descriptions of the configuration file. The values you enter inside the criteria dictionary are patterns that will be compared to the corresponding key of the sidecar. The pattern matching is shell-style. It's possible to use wildcard * , single character ? etc ... Please have a look at the GNU documentation to know more. For example, in the second description, the pattern *T2* will be compared to the value of SeriesDescription of a sidecar. AXIAL_T2_SPACE will be a match, AXIAL_T1 won't. dcm2bids has a SidecarFilename key, as in the first description, if you prefer to also match with the filename of the sidecar. You can enter several criteria. All criteria must match for a description to be linked to a sidecar.","title":"criteria"},{"location":"docs/3-configuration/#datatype","text":"It is a mandatory field. Here is a definition from bids v1.2.0 : Data type - a functional group of different types of data. In BIDS we define six data types: func (task based and resting state functional MRI), dwi (diffusion weighted imaging), fmap (field inhomogeneity mapping data such as field maps), anat (structural imaging such as T1, T2, etc.), meg (magnetoencephalography), beh (behavioral).","title":"dataType"},{"location":"docs/3-configuration/#modalitylabel","text":"It is a mandatory field. It describes the modality of the acquisition like T1w , T2w or dwi , bold .","title":"modalityLabel"},{"location":"docs/3-configuration/#customlabels","text":"It is an optional field. For some acquisitions, you need to add information in the file name. For resting state fMRI, it is usually task-rest . To know more on how to set these fields, read the BIDS specifications . For a longer example of a Dcm2Bids config json, see here .","title":"customLabels"},{"location":"docs/3-configuration/#sidecarchanges","text":"Optional field to change or add information in a sidecar.","title":"sidecarChanges"},{"location":"docs/3-configuration/#intendedfor","text":"Optional field to add an IntendedFor entry in the sidecar of a fieldmap. Just put the index or a list of indices of the description(s) that's intended for. Python index begins at 0 so in the example, 0 means it is intended for task-rest_bold . For each acquisition, dcm2niix creates an associated .json file, containing information from the dicom header. These are known as sidecars . These are the sidecars dcm2bids uses to filter the groups of acquisitions. To define this filtering you will probably need to review these sidecars. You can generate all the sidecars for an individual participant using dcm2bids_helper . \u21a9 \u21a9","title":"intendedFor"},{"location":"docs/4-advanced/","text":"Advanced configuration These optional configurations could be insert in the configuration file at the same level as the \"descriptions\" entry. { \"searchMethod\": \"fnmatch\", \"caseSensitive\": true, \"defaceTpl\": \"pydeface --outfile {dstFile} {srcFile}\", \"description\": [ ... ] } searchMethod default: \"searchMethod\": \"fnmatch\" fnmatch is the behaviour (See criteria) by default and the fall back if this option is set incorrectly. re is the other choice if you want more flexibility to match criteria. caseSensitive default: \"caseSensitive\": \"true\" If false, comparisons between strings/lists will be not case sensitive. It's only disabled when used with \"searchMethod\": \"fnmatch\" . defaceTpl default: \"defaceTpl\": None Danger The anonymizer option no longer exists from v2.0.0 . It is still possible to deface the anatomical nifti images. For example, if you use the last version of pydeface, add: \"defaceTpl\": \"pydeface --outfile {dstFile} {srcFile}\" It is a template string and dcm2bids will replace {srcFile} and {dstFile} by the source file (input) and the destination file (output). dcm2niixOptions default: \"dcm2niixOptions\": \"-b y -ba y -z y -f '%3s_%f_%p_%t'\" Arguments for dcm2niix compKeys default: \"compKeys\": [\"SeriesNumber\", \"AcquisitionTime\", \"SidecarFilename\"] Acquisitions are sorted using the sidecar data. The default behaviour is to sort by SeriesNumber then by AcquisitionTime then by the SidecarFilename . You can change this behaviour setting this key inside the configuration file.","title":"4. Advanced"},{"location":"docs/4-advanced/#advanced-configuration","text":"These optional configurations could be insert in the configuration file at the same level as the \"descriptions\" entry. { \"searchMethod\": \"fnmatch\", \"caseSensitive\": true, \"defaceTpl\": \"pydeface --outfile {dstFile} {srcFile}\", \"description\": [ ... ] }","title":"Advanced configuration"},{"location":"docs/4-advanced/#searchmethod","text":"default: \"searchMethod\": \"fnmatch\" fnmatch is the behaviour (See criteria) by default and the fall back if this option is set incorrectly. re is the other choice if you want more flexibility to match criteria.","title":"searchMethod"},{"location":"docs/4-advanced/#casesensitive","text":"default: \"caseSensitive\": \"true\" If false, comparisons between strings/lists will be not case sensitive. It's only disabled when used with \"searchMethod\": \"fnmatch\" .","title":"caseSensitive"},{"location":"docs/4-advanced/#defacetpl","text":"default: \"defaceTpl\": None Danger The anonymizer option no longer exists from v2.0.0 . It is still possible to deface the anatomical nifti images. For example, if you use the last version of pydeface, add: \"defaceTpl\": \"pydeface --outfile {dstFile} {srcFile}\" It is a template string and dcm2bids will replace {srcFile} and {dstFile} by the source file (input) and the destination file (output).","title":"defaceTpl"},{"location":"docs/4-advanced/#dcm2niixoptions","text":"default: \"dcm2niixOptions\": \"-b y -ba y -z y -f '%3s_%f_%p_%t'\" Arguments for dcm2niix","title":"dcm2niixOptions"},{"location":"docs/4-advanced/#compkeys","text":"default: \"compKeys\": [\"SeriesNumber\", \"AcquisitionTime\", \"SidecarFilename\"] Acquisitions are sorted using the sidecar data. The default behaviour is to sort by SeriesNumber then by AcquisitionTime then by the SidecarFilename . You can change this behaviour setting this key inside the configuration file.","title":"compKeys"},{"location":"reference/dcm2bids/","text":"Module dcm2bids dcm2bids Reorganising NIfTI files from dcm2niix into the Brain Imaging Data Structure View Source # -*- coding: utf-8 -*- \"\"\" dcm2bids -------- Reorganising NIfTI files from dcm2niix into the Brain Imaging Data Structure \"\"\" from .dcm2bids import Dcm2bids from .scaffold import scaffold from .version import __version__ __all__ = [\"__version__\", \"Dcm2bids\", \"scaffold\"] Sub-modules dcm2bids.dcm2bids dcm2bids.dcm2niix dcm2bids.helper dcm2bids.logger dcm2bids.scaffold dcm2bids.sidecar dcm2bids.structure dcm2bids.utils dcm2bids.version Variables __version__ Functions scaffold def scaffold ( ) scaffold entry point View Source def scaffold(): \"\"\"scaffold entry point\"\"\" args = _get_arguments() for _ in [\"code\", \"derivatives\", \"sourcedata\"]: os.makedirs(os.path.join(args.output_dir, _), exist_ok=True) for _ in [ \"dataset_description.json\", \"participants.json\", \"participants.tsv\", \"README\", ]: dest = os.path.join(args.output_dir, _) with resources.path(__name__, _) as src: shutil.copyfile(src, dest) with resources.path(__name__, \"CHANGES\") as changes_template: with open(changes_template) as _: data = _.read().format(datetime.date.today().strftime(\"%Y-%m-%d\")) write_txt( os.path.join(args.output_dir, \"CHANGES\"), data.split(\"\\n\")[:-1], ) Classes Dcm2bids class Dcm2bids ( dicom_dir , participant , config , output_dir = '/home/runner/work/Dcm2Bids/Dcm2Bids' , session = '' , clobber = False , forceDcm2niix = False , log_level = 'WARNING' , ** _ ) Attributes Name Type Description Default dicom_dir str or list A list of folder with dicoms to convert None participant str Label of your participant None config path Path to a dcm2bids configuration file None output_dir path Path to the BIDS base folder None session str Optional label of a session None clobber boolean Overwrite file if already in BIDS folder None forceDcm2niix boolean Forces a cleaning of a previous execution of dcm2niix None log_level str logging level None View Source class Dcm2bids(object): \"\"\" Object to handle dcm2bids execution steps Args: dicom_dir (str or list): A list of folder with dicoms to convert participant (str): Label of your participant config (path): Path to a dcm2bids configuration file output_dir (path): Path to the BIDS base folder session (str): Optional label of a session clobber (boolean): Overwrite file if already in BIDS folder forceDcm2niix (boolean): Forces a cleaning of a previous execution of dcm2niix log_level (str): logging level \"\"\" def __init__( self, dicom_dir, participant, config, output_dir=DEFAULT.outputDir, session=DEFAULT.session, clobber=DEFAULT.clobber, forceDcm2niix=DEFAULT.forceDcm2niix, log_level=DEFAULT.logLevel, **_ ): self._dicomDirs = [] self.dicomDirs = dicom_dir self.bidsDir = output_dir self.config = load_json(config) self.participant = Participant(participant, session) self.clobber = clobber self.forceDcm2niix = forceDcm2niix self.logLevel = log_level # logging setup self.set_logger() self.logger.info(\"--- dcm2bids start ---\") self.logger.info(\"OS:version: %s\", platform.platform()) self.logger.info(\"python:version: %s\", sys.version.replace(\"\\n\", \"\")) self.logger.info(\"dcm2bids:version: %s\", __version__) self.logger.info(\"dcm2niix:version: %s\", dcm2niix_version()) self.logger.info(\"participant: %s\", self.participant.name) self.logger.info(\"session: %s\", self.participant.session) self.logger.info(\"config: %s\", os.path.realpath(config)) self.logger.info(\"BIDS directory: %s\", os.path.realpath(output_dir)) @property def dicomDirs(self): \"\"\"List of DICOMs directories\"\"\" return self._dicomDirs @dicomDirs.setter def dicomDirs(self, value): if isinstance(value, list): dicom_dirs = value else: dicom_dirs = [value] dir_not_found = [] for _dir in dicom_dirs: if os.path.isdir(_dir): pass else: dir_not_found.append(_dir) if dir_not_found: raise FileNotFoundError(dir_not_found) self._dicomDirs = dicom_dirs def set_logger(self): \"\"\" Set a basic logger\"\"\" logDir = os.path.join(self.bidsDir, DEFAULT.tmpDirName, \"log\") logFile = os.path.join( logDir, \"{}_{}.log\".format( self.participant.prefix, datetime.now().isoformat().replace(\":\", \"\") ), ) # os.makedirs(logdir, exist_ok=True) # python2 compatibility if not os.path.exists(logDir): os.makedirs(logDir) setup_logging(self.logLevel, logFile) self.logger = logging.getLogger(__name__) def run(self): \"\"\"Run dcm2bids\"\"\" dcm2niix = Dcm2niix( self.dicomDirs, self.bidsDir, self.participant, self.config.get(\"dcm2niixOptions\", DEFAULT.dcm2niixOptions), ) dcm2niix.run(self.forceDcm2niix) sidecars = [] for filename in dcm2niix.sidecarFiles: sidecars.append( Sidecar(filename, self.config.get(\"compKeys\", DEFAULT.compKeys)) ) sidecars = sorted(sidecars) parser = SidecarPairing( sidecars, self.config[\"descriptions\"], self.config.get(\"searchMethod\", DEFAULT.searchMethod), self.config.get(\"caseSensitive\", DEFAULT.caseSensitive) ) parser.build_graph() parser.build_acquisitions(self.participant) parser.find_runs() self.logger.info(\"moving acquisitions into BIDS folder\") for acq in parser.acquisitions: self.move(acq) check_latest() check_latest(\"dcm2niix\") def move(self, acquisition): \"\"\"Move an acquisition to BIDS format\"\"\" for srcFile in glob(acquisition.srcRoot + \".*\"): _, ext = splitext_(srcFile) dstFile = os.path.join(self.bidsDir, acquisition.dstRoot + ext) # os.makedirs(os.path.dirname(dstFile), exist_ok=True) # python2 compatibility if not os.path.exists(os.path.dirname(dstFile)): os.makedirs(os.path.dirname(dstFile)) # checking if destination file exists if os.path.isfile(dstFile): self.logger.info(\"'%s' already exists\", dstFile) if self.clobber: self.logger.info(\"Overwriting because of 'clobber' option\") else: self.logger.info(\"Use clobber option to overwrite\") continue # it's an anat nifti file and the user using a deface script if ( self.config.get(\"defaceTpl\") and acquisition.dataType == \"anat\" and \".nii\" in ext ): try: os.remove(dstFile) except FileNotFoundError: pass defaceTpl = self.config.get(\"defaceTpl\") cmd = defaceTpl.format(srcFile=srcFile, dstFile=dstFile) run_shell_command(cmd) # use elif ext == \".json\": data = acquisition.dstSidecarData(self.config[\"descriptions\"]) save_json(dstFile, data) os.remove(srcFile) # just move else: os.rename(srcFile, dstFile) Instance variables dicomDirs List of DICOMs directories Methods move def move ( self , acquisition ) Move an acquisition to BIDS format View Source def move(self, acquisition): \"\"\"Move an acquisition to BIDS format\"\"\" for srcFile in glob(acquisition.srcRoot + \".*\"): _, ext = splitext_(srcFile) dstFile = os.path.join(self.bidsDir, acquisition.dstRoot + ext) # os.makedirs(os.path.dirname(dstFile), exist_ok=True) # python2 compatibility if not os.path.exists(os.path.dirname(dstFile)): os.makedirs(os.path.dirname(dstFile)) # checking if destination file exists if os.path.isfile(dstFile): self.logger.info(\"'%s' already exists\", dstFile) if self.clobber: self.logger.info(\"Overwriting because of 'clobber' option\") else: self.logger.info(\"Use clobber option to overwrite\") continue # it's an anat nifti file and the user using a deface script if ( self.config.get(\"defaceTpl\") and acquisition.dataType == \"anat\" and \".nii\" in ext ): try: os.remove(dstFile) except FileNotFoundError: pass defaceTpl = self.config.get(\"defaceTpl\") cmd = defaceTpl.format(srcFile=srcFile, dstFile=dstFile) run_shell_command(cmd) # use elif ext == \".json\": data = acquisition.dstSidecarData(self.config[\"descriptions\"]) save_json(dstFile, data) os.remove(srcFile) # just move else: os.rename(srcFile, dstFile) run def run ( self ) Run dcm2bids View Source def run(self): \"\"\"Run dcm2bids\"\"\" dcm2niix = Dcm2niix( self.dicomDirs, self.bidsDir, self.participant, self.config.get(\"dcm2niixOptions\", DEFAULT.dcm2niixOptions), ) dcm2niix.run(self.forceDcm2niix) sidecars = [] for filename in dcm2niix.sidecarFiles: sidecars.append( Sidecar(filename, self.config.get(\"compKeys\", DEFAULT.compKeys)) ) sidecars = sorted(sidecars) parser = SidecarPairing( sidecars, self.config[\"descriptions\"], self.config.get(\"searchMethod\", DEFAULT.searchMethod), self.config.get(\"caseSensitive\", DEFAULT.caseSensitive) ) parser.build_graph() parser.build_acquisitions(self.participant) parser.find_runs() self.logger.info(\"moving acquisitions into BIDS folder\") for acq in parser.acquisitions: self.move(acq) check_latest() check_latest(\"dcm2niix\") set_logger def set_logger ( self ) Set a basic logger View Source def set_logger(self): \"\"\" Set a basic logger\"\"\" logDir = os.path.join(self.bidsDir, DEFAULT.tmpDirName, \"log\") logFile = os.path.join( logDir, \"{}_{}.log\".format( self.participant.prefix, datetime.now().isoformat().replace(\":\", \"\") ), ) # os.makedirs(logdir, exist_ok=True) # python2 compatibility if not os.path.exists(logDir): os.makedirs(logDir) setup_logging(self.logLevel, logFile) self.logger = logging.getLogger(__name__)","title":"Index"},{"location":"reference/dcm2bids/#module-dcm2bids","text":"dcm2bids Reorganising NIfTI files from dcm2niix into the Brain Imaging Data Structure View Source # -*- coding: utf-8 -*- \"\"\" dcm2bids -------- Reorganising NIfTI files from dcm2niix into the Brain Imaging Data Structure \"\"\" from .dcm2bids import Dcm2bids from .scaffold import scaffold from .version import __version__ __all__ = [\"__version__\", \"Dcm2bids\", \"scaffold\"]","title":"Module dcm2bids"},{"location":"reference/dcm2bids/#sub-modules","text":"dcm2bids.dcm2bids dcm2bids.dcm2niix dcm2bids.helper dcm2bids.logger dcm2bids.scaffold dcm2bids.sidecar dcm2bids.structure dcm2bids.utils dcm2bids.version","title":"Sub-modules"},{"location":"reference/dcm2bids/#variables","text":"__version__","title":"Variables"},{"location":"reference/dcm2bids/#functions","text":"","title":"Functions"},{"location":"reference/dcm2bids/#scaffold","text":"def scaffold ( ) scaffold entry point View Source def scaffold(): \"\"\"scaffold entry point\"\"\" args = _get_arguments() for _ in [\"code\", \"derivatives\", \"sourcedata\"]: os.makedirs(os.path.join(args.output_dir, _), exist_ok=True) for _ in [ \"dataset_description.json\", \"participants.json\", \"participants.tsv\", \"README\", ]: dest = os.path.join(args.output_dir, _) with resources.path(__name__, _) as src: shutil.copyfile(src, dest) with resources.path(__name__, \"CHANGES\") as changes_template: with open(changes_template) as _: data = _.read().format(datetime.date.today().strftime(\"%Y-%m-%d\")) write_txt( os.path.join(args.output_dir, \"CHANGES\"), data.split(\"\\n\")[:-1], )","title":"scaffold"},{"location":"reference/dcm2bids/#classes","text":"","title":"Classes"},{"location":"reference/dcm2bids/#dcm2bids","text":"class Dcm2bids ( dicom_dir , participant , config , output_dir = '/home/runner/work/Dcm2Bids/Dcm2Bids' , session = '' , clobber = False , forceDcm2niix = False , log_level = 'WARNING' , ** _ )","title":"Dcm2bids"},{"location":"reference/dcm2bids/#attributes","text":"Name Type Description Default dicom_dir str or list A list of folder with dicoms to convert None participant str Label of your participant None config path Path to a dcm2bids configuration file None output_dir path Path to the BIDS base folder None session str Optional label of a session None clobber boolean Overwrite file if already in BIDS folder None forceDcm2niix boolean Forces a cleaning of a previous execution of dcm2niix None log_level str logging level None View Source class Dcm2bids(object): \"\"\" Object to handle dcm2bids execution steps Args: dicom_dir (str or list): A list of folder with dicoms to convert participant (str): Label of your participant config (path): Path to a dcm2bids configuration file output_dir (path): Path to the BIDS base folder session (str): Optional label of a session clobber (boolean): Overwrite file if already in BIDS folder forceDcm2niix (boolean): Forces a cleaning of a previous execution of dcm2niix log_level (str): logging level \"\"\" def __init__( self, dicom_dir, participant, config, output_dir=DEFAULT.outputDir, session=DEFAULT.session, clobber=DEFAULT.clobber, forceDcm2niix=DEFAULT.forceDcm2niix, log_level=DEFAULT.logLevel, **_ ): self._dicomDirs = [] self.dicomDirs = dicom_dir self.bidsDir = output_dir self.config = load_json(config) self.participant = Participant(participant, session) self.clobber = clobber self.forceDcm2niix = forceDcm2niix self.logLevel = log_level # logging setup self.set_logger() self.logger.info(\"--- dcm2bids start ---\") self.logger.info(\"OS:version: %s\", platform.platform()) self.logger.info(\"python:version: %s\", sys.version.replace(\"\\n\", \"\")) self.logger.info(\"dcm2bids:version: %s\", __version__) self.logger.info(\"dcm2niix:version: %s\", dcm2niix_version()) self.logger.info(\"participant: %s\", self.participant.name) self.logger.info(\"session: %s\", self.participant.session) self.logger.info(\"config: %s\", os.path.realpath(config)) self.logger.info(\"BIDS directory: %s\", os.path.realpath(output_dir)) @property def dicomDirs(self): \"\"\"List of DICOMs directories\"\"\" return self._dicomDirs @dicomDirs.setter def dicomDirs(self, value): if isinstance(value, list): dicom_dirs = value else: dicom_dirs = [value] dir_not_found = [] for _dir in dicom_dirs: if os.path.isdir(_dir): pass else: dir_not_found.append(_dir) if dir_not_found: raise FileNotFoundError(dir_not_found) self._dicomDirs = dicom_dirs def set_logger(self): \"\"\" Set a basic logger\"\"\" logDir = os.path.join(self.bidsDir, DEFAULT.tmpDirName, \"log\") logFile = os.path.join( logDir, \"{}_{}.log\".format( self.participant.prefix, datetime.now().isoformat().replace(\":\", \"\") ), ) # os.makedirs(logdir, exist_ok=True) # python2 compatibility if not os.path.exists(logDir): os.makedirs(logDir) setup_logging(self.logLevel, logFile) self.logger = logging.getLogger(__name__) def run(self): \"\"\"Run dcm2bids\"\"\" dcm2niix = Dcm2niix( self.dicomDirs, self.bidsDir, self.participant, self.config.get(\"dcm2niixOptions\", DEFAULT.dcm2niixOptions), ) dcm2niix.run(self.forceDcm2niix) sidecars = [] for filename in dcm2niix.sidecarFiles: sidecars.append( Sidecar(filename, self.config.get(\"compKeys\", DEFAULT.compKeys)) ) sidecars = sorted(sidecars) parser = SidecarPairing( sidecars, self.config[\"descriptions\"], self.config.get(\"searchMethod\", DEFAULT.searchMethod), self.config.get(\"caseSensitive\", DEFAULT.caseSensitive) ) parser.build_graph() parser.build_acquisitions(self.participant) parser.find_runs() self.logger.info(\"moving acquisitions into BIDS folder\") for acq in parser.acquisitions: self.move(acq) check_latest() check_latest(\"dcm2niix\") def move(self, acquisition): \"\"\"Move an acquisition to BIDS format\"\"\" for srcFile in glob(acquisition.srcRoot + \".*\"): _, ext = splitext_(srcFile) dstFile = os.path.join(self.bidsDir, acquisition.dstRoot + ext) # os.makedirs(os.path.dirname(dstFile), exist_ok=True) # python2 compatibility if not os.path.exists(os.path.dirname(dstFile)): os.makedirs(os.path.dirname(dstFile)) # checking if destination file exists if os.path.isfile(dstFile): self.logger.info(\"'%s' already exists\", dstFile) if self.clobber: self.logger.info(\"Overwriting because of 'clobber' option\") else: self.logger.info(\"Use clobber option to overwrite\") continue # it's an anat nifti file and the user using a deface script if ( self.config.get(\"defaceTpl\") and acquisition.dataType == \"anat\" and \".nii\" in ext ): try: os.remove(dstFile) except FileNotFoundError: pass defaceTpl = self.config.get(\"defaceTpl\") cmd = defaceTpl.format(srcFile=srcFile, dstFile=dstFile) run_shell_command(cmd) # use elif ext == \".json\": data = acquisition.dstSidecarData(self.config[\"descriptions\"]) save_json(dstFile, data) os.remove(srcFile) # just move else: os.rename(srcFile, dstFile)","title":"Attributes"},{"location":"reference/dcm2bids/#instance-variables","text":"dicomDirs List of DICOMs directories","title":"Instance variables"},{"location":"reference/dcm2bids/#methods","text":"","title":"Methods"},{"location":"reference/dcm2bids/#move","text":"def move ( self , acquisition ) Move an acquisition to BIDS format View Source def move(self, acquisition): \"\"\"Move an acquisition to BIDS format\"\"\" for srcFile in glob(acquisition.srcRoot + \".*\"): _, ext = splitext_(srcFile) dstFile = os.path.join(self.bidsDir, acquisition.dstRoot + ext) # os.makedirs(os.path.dirname(dstFile), exist_ok=True) # python2 compatibility if not os.path.exists(os.path.dirname(dstFile)): os.makedirs(os.path.dirname(dstFile)) # checking if destination file exists if os.path.isfile(dstFile): self.logger.info(\"'%s' already exists\", dstFile) if self.clobber: self.logger.info(\"Overwriting because of 'clobber' option\") else: self.logger.info(\"Use clobber option to overwrite\") continue # it's an anat nifti file and the user using a deface script if ( self.config.get(\"defaceTpl\") and acquisition.dataType == \"anat\" and \".nii\" in ext ): try: os.remove(dstFile) except FileNotFoundError: pass defaceTpl = self.config.get(\"defaceTpl\") cmd = defaceTpl.format(srcFile=srcFile, dstFile=dstFile) run_shell_command(cmd) # use elif ext == \".json\": data = acquisition.dstSidecarData(self.config[\"descriptions\"]) save_json(dstFile, data) os.remove(srcFile) # just move else: os.rename(srcFile, dstFile)","title":"move"},{"location":"reference/dcm2bids/#run","text":"def run ( self ) Run dcm2bids View Source def run(self): \"\"\"Run dcm2bids\"\"\" dcm2niix = Dcm2niix( self.dicomDirs, self.bidsDir, self.participant, self.config.get(\"dcm2niixOptions\", DEFAULT.dcm2niixOptions), ) dcm2niix.run(self.forceDcm2niix) sidecars = [] for filename in dcm2niix.sidecarFiles: sidecars.append( Sidecar(filename, self.config.get(\"compKeys\", DEFAULT.compKeys)) ) sidecars = sorted(sidecars) parser = SidecarPairing( sidecars, self.config[\"descriptions\"], self.config.get(\"searchMethod\", DEFAULT.searchMethod), self.config.get(\"caseSensitive\", DEFAULT.caseSensitive) ) parser.build_graph() parser.build_acquisitions(self.participant) parser.find_runs() self.logger.info(\"moving acquisitions into BIDS folder\") for acq in parser.acquisitions: self.move(acq) check_latest() check_latest(\"dcm2niix\")","title":"run"},{"location":"reference/dcm2bids/#set_logger","text":"def set_logger ( self ) Set a basic logger View Source def set_logger(self): \"\"\" Set a basic logger\"\"\" logDir = os.path.join(self.bidsDir, DEFAULT.tmpDirName, \"log\") logFile = os.path.join( logDir, \"{}_{}.log\".format( self.participant.prefix, datetime.now().isoformat().replace(\":\", \"\") ), ) # os.makedirs(logdir, exist_ok=True) # python2 compatibility if not os.path.exists(logDir): os.makedirs(logDir) setup_logging(self.logLevel, logFile) self.logger = logging.getLogger(__name__)","title":"set_logger"},{"location":"reference/dcm2bids/dcm2bids/","text":"Module dcm2bids.dcm2bids dcm2bids module None View Source # -*- coding: utf-8 -*- \"\"\"dcm2bids module\"\"\" import argparse import logging import os import platform import sys from datetime import datetime from glob import glob from .dcm2niix import Dcm2niix from .logger import setup_logging from .sidecar import Sidecar, SidecarPairing from .structure import Participant from .utils import DEFAULT, load_json, save_json, run_shell_command, splitext_ from .version import __version__, check_latest, dcm2niix_version class Dcm2bids(object): \"\"\" Object to handle dcm2bids execution steps Args: dicom_dir (str or list): A list of folder with dicoms to convert participant (str): Label of your participant config (path): Path to a dcm2bids configuration file output_dir (path): Path to the BIDS base folder session (str): Optional label of a session clobber (boolean): Overwrite file if already in BIDS folder forceDcm2niix (boolean): Forces a cleaning of a previous execution of dcm2niix log_level (str): logging level \"\"\" def __init__( self, dicom_dir, participant, config, output_dir=DEFAULT.outputDir, session=DEFAULT.session, clobber=DEFAULT.clobber, forceDcm2niix=DEFAULT.forceDcm2niix, log_level=DEFAULT.logLevel, **_ ): self._dicomDirs = [] self.dicomDirs = dicom_dir self.bidsDir = output_dir self.config = load_json(config) self.participant = Participant(participant, session) self.clobber = clobber self.forceDcm2niix = forceDcm2niix self.logLevel = log_level # logging setup self.set_logger() self.logger.info(\"--- dcm2bids start ---\") self.logger.info(\"OS:version: %s\", platform.platform()) self.logger.info(\"python:version: %s\", sys.version.replace(\"\\n\", \"\")) self.logger.info(\"dcm2bids:version: %s\", __version__) self.logger.info(\"dcm2niix:version: %s\", dcm2niix_version()) self.logger.info(\"participant: %s\", self.participant.name) self.logger.info(\"session: %s\", self.participant.session) self.logger.info(\"config: %s\", os.path.realpath(config)) self.logger.info(\"BIDS directory: %s\", os.path.realpath(output_dir)) @property def dicomDirs(self): \"\"\"List of DICOMs directories\"\"\" return self._dicomDirs @dicomDirs.setter def dicomDirs(self, value): if isinstance(value, list): dicom_dirs = value else: dicom_dirs = [value] dir_not_found = [] for _dir in dicom_dirs: if os.path.isdir(_dir): pass else: dir_not_found.append(_dir) if dir_not_found: raise FileNotFoundError(dir_not_found) self._dicomDirs = dicom_dirs def set_logger(self): \"\"\" Set a basic logger\"\"\" logDir = os.path.join(self.bidsDir, DEFAULT.tmpDirName, \"log\") logFile = os.path.join( logDir, \"{}_{}.log\".format( self.participant.prefix, datetime.now().isoformat().replace(\":\", \"\") ), ) # os.makedirs(logdir, exist_ok=True) # python2 compatibility if not os.path.exists(logDir): os.makedirs(logDir) setup_logging(self.logLevel, logFile) self.logger = logging.getLogger(__name__) def run(self): \"\"\"Run dcm2bids\"\"\" dcm2niix = Dcm2niix( self.dicomDirs, self.bidsDir, self.participant, self.config.get(\"dcm2niixOptions\", DEFAULT.dcm2niixOptions), ) dcm2niix.run(self.forceDcm2niix) sidecars = [] for filename in dcm2niix.sidecarFiles: sidecars.append( Sidecar(filename, self.config.get(\"compKeys\", DEFAULT.compKeys)) ) sidecars = sorted(sidecars) parser = SidecarPairing( sidecars, self.config[\"descriptions\"], self.config.get(\"searchMethod\", DEFAULT.searchMethod), self.config.get(\"caseSensitive\", DEFAULT.caseSensitive) ) parser.build_graph() parser.build_acquisitions(self.participant) parser.find_runs() self.logger.info(\"moving acquisitions into BIDS folder\") for acq in parser.acquisitions: self.move(acq) check_latest() check_latest(\"dcm2niix\") def move(self, acquisition): \"\"\"Move an acquisition to BIDS format\"\"\" for srcFile in glob(acquisition.srcRoot + \".*\"): _, ext = splitext_(srcFile) dstFile = os.path.join(self.bidsDir, acquisition.dstRoot + ext) # os.makedirs(os.path.dirname(dstFile), exist_ok=True) # python2 compatibility if not os.path.exists(os.path.dirname(dstFile)): os.makedirs(os.path.dirname(dstFile)) # checking if destination file exists if os.path.isfile(dstFile): self.logger.info(\"'%s' already exists\", dstFile) if self.clobber: self.logger.info(\"Overwriting because of 'clobber' option\") else: self.logger.info(\"Use clobber option to overwrite\") continue # it's an anat nifti file and the user using a deface script if ( self.config.get(\"defaceTpl\") and acquisition.dataType == \"anat\" and \".nii\" in ext ): try: os.remove(dstFile) except FileNotFoundError: pass defaceTpl = self.config.get(\"defaceTpl\") cmd = defaceTpl.format(srcFile=srcFile, dstFile=dstFile) run_shell_command(cmd) # use elif ext == \".json\": data = acquisition.dstSidecarData(self.config[\"descriptions\"]) save_json(dstFile, data) os.remove(srcFile) # just move else: os.rename(srcFile, dstFile) def get_arguments(): \"\"\"Load arguments for main\"\"\" parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, description=\"\"\" Reorganising NIfTI files from dcm2niix into the Brain Imaging Data Structure dcm2bids {}\"\"\".format( __version__ ), epilog=\"\"\" Documentation at https://github.com/unfmontreal/Dcm2Bids \"\"\", ) parser.add_argument( \"-d\", \"--dicom_dir\", required=True, nargs=\"+\", help=\"DICOM directory(ies)\" ) parser.add_argument(\"-p\", \"--participant\", required=True, help=\"Participant ID\") parser.add_argument( \"-s\", \"--session\", required=False, default=DEFAULT.cliSession, help=\"Session ID\" ) parser.add_argument( \"-c\", \"--config\", required=True, help=\"JSON configuration file (see example/config.json)\", ) parser.add_argument( \"-o\", \"--output_dir\", required=False, default=DEFAULT.cliOutputDir, help=\"Output BIDS directory, Default: current directory ({})\".format( DEFAULT.cliOutputDir ), ) parser.add_argument( \"--forceDcm2niix\", required=False, action=\"store_true\", help=\"Overwrite previous temporary dcm2niix output if it exists\", ) parser.add_argument( \"--clobber\", required=False, action=\"store_true\", help=\"Overwrite output if it exists\", ) parser.add_argument( \"-l\", \"--log_level\", required=False, default=DEFAULT.cliLogLevel, choices=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"], help=\"Set logging level\", ) parser.add_argument( \"-a\", \"--anonymizer\", required=False, action=\"store_true\", help=\"\"\" This option no longer exists from the script in this release. See:https://github.com/unfmontreal/Dcm2Bids/blob/master/README.md#defaceTpl\"\"\", ) args = parser.parse_args() return args def main(): \"\"\"Let's go\"\"\" args = get_arguments() if args.anonymizer: print( \"\"\" The anonymizer option no longer exists from the script in this release It is still possible to deface the anatomical nifti images Please add \"defaceTpl\" key in the congifuration file For example, if you use the last version of pydeface, add: \"defaceTpl\": \"pydeface --outfile {dstFile} {srcFile}\" It is a template string and dcm2bids will replace {srcFile} and {dstFile} by the source file (input) and the destination file (output) \"\"\" ) return 1 app = Dcm2bids(**vars(args)) return app.run() if __name__ == \"__main__\": sys.exit(main()) Functions get_arguments def get_arguments ( ) Load arguments for main View Source def get_arguments(): \"\"\"Load arguments for main\"\"\" parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, description=\"\"\" Reorganising NIfTI files from dcm2niix into the Brain Imaging Data Structure dcm2bids {}\"\"\".format( __version__ ), epilog=\"\"\" Documentation at https://github.com/unfmontreal/Dcm2Bids \"\"\", ) parser.add_argument( \"-d\", \"--dicom_dir\", required=True, nargs=\"+\", help=\"DICOM directory(ies)\" ) parser.add_argument(\"-p\", \"--participant\", required=True, help=\"Participant ID\") parser.add_argument( \"-s\", \"--session\", required=False, default=DEFAULT.cliSession, help=\"Session ID\" ) parser.add_argument( \"-c\", \"--config\", required=True, help=\"JSON configuration file (see example/config.json)\", ) parser.add_argument( \"-o\", \"--output_dir\", required=False, default=DEFAULT.cliOutputDir, help=\"Output BIDS directory, Default: current directory ({})\".format( DEFAULT.cliOutputDir ), ) parser.add_argument( \"--forceDcm2niix\", required=False, action=\"store_true\", help=\"Overwrite previous temporary dcm2niix output if it exists\", ) parser.add_argument( \"--clobber\", required=False, action=\"store_true\", help=\"Overwrite output if it exists\", ) parser.add_argument( \"-l\", \"--log_level\", required=False, default=DEFAULT.cliLogLevel, choices=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"], help=\"Set logging level\", ) parser.add_argument( \"-a\", \"--anonymizer\", required=False, action=\"store_true\", help=\"\"\" This option no longer exists from the script in this release. See:https://github.com/unfmontreal/Dcm2Bids/blob/master/README.md#defaceTpl\"\"\", ) args = parser.parse_args() return args main def main ( ) Let's go View Source def main(): \"\"\"Let's go\"\"\" args = get_arguments() if args.anonymizer: print( \"\"\" The anonymizer option no longer exists from the script in this release It is still possible to deface the anatomical nifti images Please add \"defaceTpl\" key in the congifuration file For example, if you use the last version of pydeface, add: \"defaceTpl\": \"pydeface --outfile {dstFile} {srcFile}\" It is a template string and dcm2bids will replace {srcFile} and {dstFile} by the source file (input) and the destination file (output) \"\"\" ) return 1 app = Dcm2bids(**vars(args)) return app.run() Classes Dcm2bids class Dcm2bids ( dicom_dir , participant , config , output_dir = '/home/runner/work/Dcm2Bids/Dcm2Bids' , session = '' , clobber = False , forceDcm2niix = False , log_level = 'WARNING' , ** _ ) Attributes Name Type Description Default dicom_dir str or list A list of folder with dicoms to convert None participant str Label of your participant None config path Path to a dcm2bids configuration file None output_dir path Path to the BIDS base folder None session str Optional label of a session None clobber boolean Overwrite file if already in BIDS folder None forceDcm2niix boolean Forces a cleaning of a previous execution of dcm2niix None log_level str logging level None View Source class Dcm2bids(object): \"\"\" Object to handle dcm2bids execution steps Args: dicom_dir (str or list): A list of folder with dicoms to convert participant (str): Label of your participant config (path): Path to a dcm2bids configuration file output_dir (path): Path to the BIDS base folder session (str): Optional label of a session clobber (boolean): Overwrite file if already in BIDS folder forceDcm2niix (boolean): Forces a cleaning of a previous execution of dcm2niix log_level (str): logging level \"\"\" def __init__( self, dicom_dir, participant, config, output_dir=DEFAULT.outputDir, session=DEFAULT.session, clobber=DEFAULT.clobber, forceDcm2niix=DEFAULT.forceDcm2niix, log_level=DEFAULT.logLevel, **_ ): self._dicomDirs = [] self.dicomDirs = dicom_dir self.bidsDir = output_dir self.config = load_json(config) self.participant = Participant(participant, session) self.clobber = clobber self.forceDcm2niix = forceDcm2niix self.logLevel = log_level # logging setup self.set_logger() self.logger.info(\"--- dcm2bids start ---\") self.logger.info(\"OS:version: %s\", platform.platform()) self.logger.info(\"python:version: %s\", sys.version.replace(\"\\n\", \"\")) self.logger.info(\"dcm2bids:version: %s\", __version__) self.logger.info(\"dcm2niix:version: %s\", dcm2niix_version()) self.logger.info(\"participant: %s\", self.participant.name) self.logger.info(\"session: %s\", self.participant.session) self.logger.info(\"config: %s\", os.path.realpath(config)) self.logger.info(\"BIDS directory: %s\", os.path.realpath(output_dir)) @property def dicomDirs(self): \"\"\"List of DICOMs directories\"\"\" return self._dicomDirs @dicomDirs.setter def dicomDirs(self, value): if isinstance(value, list): dicom_dirs = value else: dicom_dirs = [value] dir_not_found = [] for _dir in dicom_dirs: if os.path.isdir(_dir): pass else: dir_not_found.append(_dir) if dir_not_found: raise FileNotFoundError(dir_not_found) self._dicomDirs = dicom_dirs def set_logger(self): \"\"\" Set a basic logger\"\"\" logDir = os.path.join(self.bidsDir, DEFAULT.tmpDirName, \"log\") logFile = os.path.join( logDir, \"{}_{}.log\".format( self.participant.prefix, datetime.now().isoformat().replace(\":\", \"\") ), ) # os.makedirs(logdir, exist_ok=True) # python2 compatibility if not os.path.exists(logDir): os.makedirs(logDir) setup_logging(self.logLevel, logFile) self.logger = logging.getLogger(__name__) def run(self): \"\"\"Run dcm2bids\"\"\" dcm2niix = Dcm2niix( self.dicomDirs, self.bidsDir, self.participant, self.config.get(\"dcm2niixOptions\", DEFAULT.dcm2niixOptions), ) dcm2niix.run(self.forceDcm2niix) sidecars = [] for filename in dcm2niix.sidecarFiles: sidecars.append( Sidecar(filename, self.config.get(\"compKeys\", DEFAULT.compKeys)) ) sidecars = sorted(sidecars) parser = SidecarPairing( sidecars, self.config[\"descriptions\"], self.config.get(\"searchMethod\", DEFAULT.searchMethod), self.config.get(\"caseSensitive\", DEFAULT.caseSensitive) ) parser.build_graph() parser.build_acquisitions(self.participant) parser.find_runs() self.logger.info(\"moving acquisitions into BIDS folder\") for acq in parser.acquisitions: self.move(acq) check_latest() check_latest(\"dcm2niix\") def move(self, acquisition): \"\"\"Move an acquisition to BIDS format\"\"\" for srcFile in glob(acquisition.srcRoot + \".*\"): _, ext = splitext_(srcFile) dstFile = os.path.join(self.bidsDir, acquisition.dstRoot + ext) # os.makedirs(os.path.dirname(dstFile), exist_ok=True) # python2 compatibility if not os.path.exists(os.path.dirname(dstFile)): os.makedirs(os.path.dirname(dstFile)) # checking if destination file exists if os.path.isfile(dstFile): self.logger.info(\"'%s' already exists\", dstFile) if self.clobber: self.logger.info(\"Overwriting because of 'clobber' option\") else: self.logger.info(\"Use clobber option to overwrite\") continue # it's an anat nifti file and the user using a deface script if ( self.config.get(\"defaceTpl\") and acquisition.dataType == \"anat\" and \".nii\" in ext ): try: os.remove(dstFile) except FileNotFoundError: pass defaceTpl = self.config.get(\"defaceTpl\") cmd = defaceTpl.format(srcFile=srcFile, dstFile=dstFile) run_shell_command(cmd) # use elif ext == \".json\": data = acquisition.dstSidecarData(self.config[\"descriptions\"]) save_json(dstFile, data) os.remove(srcFile) # just move else: os.rename(srcFile, dstFile) Instance variables dicomDirs List of DICOMs directories Methods move def move ( self , acquisition ) Move an acquisition to BIDS format View Source def move(self, acquisition): \"\"\"Move an acquisition to BIDS format\"\"\" for srcFile in glob(acquisition.srcRoot + \".*\"): _, ext = splitext_(srcFile) dstFile = os.path.join(self.bidsDir, acquisition.dstRoot + ext) # os.makedirs(os.path.dirname(dstFile), exist_ok=True) # python2 compatibility if not os.path.exists(os.path.dirname(dstFile)): os.makedirs(os.path.dirname(dstFile)) # checking if destination file exists if os.path.isfile(dstFile): self.logger.info(\"'%s' already exists\", dstFile) if self.clobber: self.logger.info(\"Overwriting because of 'clobber' option\") else: self.logger.info(\"Use clobber option to overwrite\") continue # it's an anat nifti file and the user using a deface script if ( self.config.get(\"defaceTpl\") and acquisition.dataType == \"anat\" and \".nii\" in ext ): try: os.remove(dstFile) except FileNotFoundError: pass defaceTpl = self.config.get(\"defaceTpl\") cmd = defaceTpl.format(srcFile=srcFile, dstFile=dstFile) run_shell_command(cmd) # use elif ext == \".json\": data = acquisition.dstSidecarData(self.config[\"descriptions\"]) save_json(dstFile, data) os.remove(srcFile) # just move else: os.rename(srcFile, dstFile) run def run ( self ) Run dcm2bids View Source def run(self): \"\"\"Run dcm2bids\"\"\" dcm2niix = Dcm2niix( self.dicomDirs, self.bidsDir, self.participant, self.config.get(\"dcm2niixOptions\", DEFAULT.dcm2niixOptions), ) dcm2niix.run(self.forceDcm2niix) sidecars = [] for filename in dcm2niix.sidecarFiles: sidecars.append( Sidecar(filename, self.config.get(\"compKeys\", DEFAULT.compKeys)) ) sidecars = sorted(sidecars) parser = SidecarPairing( sidecars, self.config[\"descriptions\"], self.config.get(\"searchMethod\", DEFAULT.searchMethod), self.config.get(\"caseSensitive\", DEFAULT.caseSensitive) ) parser.build_graph() parser.build_acquisitions(self.participant) parser.find_runs() self.logger.info(\"moving acquisitions into BIDS folder\") for acq in parser.acquisitions: self.move(acq) check_latest() check_latest(\"dcm2niix\") set_logger def set_logger ( self ) Set a basic logger View Source def set_logger(self): \"\"\" Set a basic logger\"\"\" logDir = os.path.join(self.bidsDir, DEFAULT.tmpDirName, \"log\") logFile = os.path.join( logDir, \"{}_{}.log\".format( self.participant.prefix, datetime.now().isoformat().replace(\":\", \"\") ), ) # os.makedirs(logdir, exist_ok=True) # python2 compatibility if not os.path.exists(logDir): os.makedirs(logDir) setup_logging(self.logLevel, logFile) self.logger = logging.getLogger(__name__)","title":"Dcm2Bids"},{"location":"reference/dcm2bids/dcm2bids/#module-dcm2bidsdcm2bids","text":"dcm2bids module None View Source # -*- coding: utf-8 -*- \"\"\"dcm2bids module\"\"\" import argparse import logging import os import platform import sys from datetime import datetime from glob import glob from .dcm2niix import Dcm2niix from .logger import setup_logging from .sidecar import Sidecar, SidecarPairing from .structure import Participant from .utils import DEFAULT, load_json, save_json, run_shell_command, splitext_ from .version import __version__, check_latest, dcm2niix_version class Dcm2bids(object): \"\"\" Object to handle dcm2bids execution steps Args: dicom_dir (str or list): A list of folder with dicoms to convert participant (str): Label of your participant config (path): Path to a dcm2bids configuration file output_dir (path): Path to the BIDS base folder session (str): Optional label of a session clobber (boolean): Overwrite file if already in BIDS folder forceDcm2niix (boolean): Forces a cleaning of a previous execution of dcm2niix log_level (str): logging level \"\"\" def __init__( self, dicom_dir, participant, config, output_dir=DEFAULT.outputDir, session=DEFAULT.session, clobber=DEFAULT.clobber, forceDcm2niix=DEFAULT.forceDcm2niix, log_level=DEFAULT.logLevel, **_ ): self._dicomDirs = [] self.dicomDirs = dicom_dir self.bidsDir = output_dir self.config = load_json(config) self.participant = Participant(participant, session) self.clobber = clobber self.forceDcm2niix = forceDcm2niix self.logLevel = log_level # logging setup self.set_logger() self.logger.info(\"--- dcm2bids start ---\") self.logger.info(\"OS:version: %s\", platform.platform()) self.logger.info(\"python:version: %s\", sys.version.replace(\"\\n\", \"\")) self.logger.info(\"dcm2bids:version: %s\", __version__) self.logger.info(\"dcm2niix:version: %s\", dcm2niix_version()) self.logger.info(\"participant: %s\", self.participant.name) self.logger.info(\"session: %s\", self.participant.session) self.logger.info(\"config: %s\", os.path.realpath(config)) self.logger.info(\"BIDS directory: %s\", os.path.realpath(output_dir)) @property def dicomDirs(self): \"\"\"List of DICOMs directories\"\"\" return self._dicomDirs @dicomDirs.setter def dicomDirs(self, value): if isinstance(value, list): dicom_dirs = value else: dicom_dirs = [value] dir_not_found = [] for _dir in dicom_dirs: if os.path.isdir(_dir): pass else: dir_not_found.append(_dir) if dir_not_found: raise FileNotFoundError(dir_not_found) self._dicomDirs = dicom_dirs def set_logger(self): \"\"\" Set a basic logger\"\"\" logDir = os.path.join(self.bidsDir, DEFAULT.tmpDirName, \"log\") logFile = os.path.join( logDir, \"{}_{}.log\".format( self.participant.prefix, datetime.now().isoformat().replace(\":\", \"\") ), ) # os.makedirs(logdir, exist_ok=True) # python2 compatibility if not os.path.exists(logDir): os.makedirs(logDir) setup_logging(self.logLevel, logFile) self.logger = logging.getLogger(__name__) def run(self): \"\"\"Run dcm2bids\"\"\" dcm2niix = Dcm2niix( self.dicomDirs, self.bidsDir, self.participant, self.config.get(\"dcm2niixOptions\", DEFAULT.dcm2niixOptions), ) dcm2niix.run(self.forceDcm2niix) sidecars = [] for filename in dcm2niix.sidecarFiles: sidecars.append( Sidecar(filename, self.config.get(\"compKeys\", DEFAULT.compKeys)) ) sidecars = sorted(sidecars) parser = SidecarPairing( sidecars, self.config[\"descriptions\"], self.config.get(\"searchMethod\", DEFAULT.searchMethod), self.config.get(\"caseSensitive\", DEFAULT.caseSensitive) ) parser.build_graph() parser.build_acquisitions(self.participant) parser.find_runs() self.logger.info(\"moving acquisitions into BIDS folder\") for acq in parser.acquisitions: self.move(acq) check_latest() check_latest(\"dcm2niix\") def move(self, acquisition): \"\"\"Move an acquisition to BIDS format\"\"\" for srcFile in glob(acquisition.srcRoot + \".*\"): _, ext = splitext_(srcFile) dstFile = os.path.join(self.bidsDir, acquisition.dstRoot + ext) # os.makedirs(os.path.dirname(dstFile), exist_ok=True) # python2 compatibility if not os.path.exists(os.path.dirname(dstFile)): os.makedirs(os.path.dirname(dstFile)) # checking if destination file exists if os.path.isfile(dstFile): self.logger.info(\"'%s' already exists\", dstFile) if self.clobber: self.logger.info(\"Overwriting because of 'clobber' option\") else: self.logger.info(\"Use clobber option to overwrite\") continue # it's an anat nifti file and the user using a deface script if ( self.config.get(\"defaceTpl\") and acquisition.dataType == \"anat\" and \".nii\" in ext ): try: os.remove(dstFile) except FileNotFoundError: pass defaceTpl = self.config.get(\"defaceTpl\") cmd = defaceTpl.format(srcFile=srcFile, dstFile=dstFile) run_shell_command(cmd) # use elif ext == \".json\": data = acquisition.dstSidecarData(self.config[\"descriptions\"]) save_json(dstFile, data) os.remove(srcFile) # just move else: os.rename(srcFile, dstFile) def get_arguments(): \"\"\"Load arguments for main\"\"\" parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, description=\"\"\" Reorganising NIfTI files from dcm2niix into the Brain Imaging Data Structure dcm2bids {}\"\"\".format( __version__ ), epilog=\"\"\" Documentation at https://github.com/unfmontreal/Dcm2Bids \"\"\", ) parser.add_argument( \"-d\", \"--dicom_dir\", required=True, nargs=\"+\", help=\"DICOM directory(ies)\" ) parser.add_argument(\"-p\", \"--participant\", required=True, help=\"Participant ID\") parser.add_argument( \"-s\", \"--session\", required=False, default=DEFAULT.cliSession, help=\"Session ID\" ) parser.add_argument( \"-c\", \"--config\", required=True, help=\"JSON configuration file (see example/config.json)\", ) parser.add_argument( \"-o\", \"--output_dir\", required=False, default=DEFAULT.cliOutputDir, help=\"Output BIDS directory, Default: current directory ({})\".format( DEFAULT.cliOutputDir ), ) parser.add_argument( \"--forceDcm2niix\", required=False, action=\"store_true\", help=\"Overwrite previous temporary dcm2niix output if it exists\", ) parser.add_argument( \"--clobber\", required=False, action=\"store_true\", help=\"Overwrite output if it exists\", ) parser.add_argument( \"-l\", \"--log_level\", required=False, default=DEFAULT.cliLogLevel, choices=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"], help=\"Set logging level\", ) parser.add_argument( \"-a\", \"--anonymizer\", required=False, action=\"store_true\", help=\"\"\" This option no longer exists from the script in this release. See:https://github.com/unfmontreal/Dcm2Bids/blob/master/README.md#defaceTpl\"\"\", ) args = parser.parse_args() return args def main(): \"\"\"Let's go\"\"\" args = get_arguments() if args.anonymizer: print( \"\"\" The anonymizer option no longer exists from the script in this release It is still possible to deface the anatomical nifti images Please add \"defaceTpl\" key in the congifuration file For example, if you use the last version of pydeface, add: \"defaceTpl\": \"pydeface --outfile {dstFile} {srcFile}\" It is a template string and dcm2bids will replace {srcFile} and {dstFile} by the source file (input) and the destination file (output) \"\"\" ) return 1 app = Dcm2bids(**vars(args)) return app.run() if __name__ == \"__main__\": sys.exit(main())","title":"Module dcm2bids.dcm2bids"},{"location":"reference/dcm2bids/dcm2bids/#functions","text":"","title":"Functions"},{"location":"reference/dcm2bids/dcm2bids/#get_arguments","text":"def get_arguments ( ) Load arguments for main View Source def get_arguments(): \"\"\"Load arguments for main\"\"\" parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, description=\"\"\" Reorganising NIfTI files from dcm2niix into the Brain Imaging Data Structure dcm2bids {}\"\"\".format( __version__ ), epilog=\"\"\" Documentation at https://github.com/unfmontreal/Dcm2Bids \"\"\", ) parser.add_argument( \"-d\", \"--dicom_dir\", required=True, nargs=\"+\", help=\"DICOM directory(ies)\" ) parser.add_argument(\"-p\", \"--participant\", required=True, help=\"Participant ID\") parser.add_argument( \"-s\", \"--session\", required=False, default=DEFAULT.cliSession, help=\"Session ID\" ) parser.add_argument( \"-c\", \"--config\", required=True, help=\"JSON configuration file (see example/config.json)\", ) parser.add_argument( \"-o\", \"--output_dir\", required=False, default=DEFAULT.cliOutputDir, help=\"Output BIDS directory, Default: current directory ({})\".format( DEFAULT.cliOutputDir ), ) parser.add_argument( \"--forceDcm2niix\", required=False, action=\"store_true\", help=\"Overwrite previous temporary dcm2niix output if it exists\", ) parser.add_argument( \"--clobber\", required=False, action=\"store_true\", help=\"Overwrite output if it exists\", ) parser.add_argument( \"-l\", \"--log_level\", required=False, default=DEFAULT.cliLogLevel, choices=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"], help=\"Set logging level\", ) parser.add_argument( \"-a\", \"--anonymizer\", required=False, action=\"store_true\", help=\"\"\" This option no longer exists from the script in this release. See:https://github.com/unfmontreal/Dcm2Bids/blob/master/README.md#defaceTpl\"\"\", ) args = parser.parse_args() return args","title":"get_arguments"},{"location":"reference/dcm2bids/dcm2bids/#main","text":"def main ( ) Let's go View Source def main(): \"\"\"Let's go\"\"\" args = get_arguments() if args.anonymizer: print( \"\"\" The anonymizer option no longer exists from the script in this release It is still possible to deface the anatomical nifti images Please add \"defaceTpl\" key in the congifuration file For example, if you use the last version of pydeface, add: \"defaceTpl\": \"pydeface --outfile {dstFile} {srcFile}\" It is a template string and dcm2bids will replace {srcFile} and {dstFile} by the source file (input) and the destination file (output) \"\"\" ) return 1 app = Dcm2bids(**vars(args)) return app.run()","title":"main"},{"location":"reference/dcm2bids/dcm2bids/#classes","text":"","title":"Classes"},{"location":"reference/dcm2bids/dcm2bids/#dcm2bids","text":"class Dcm2bids ( dicom_dir , participant , config , output_dir = '/home/runner/work/Dcm2Bids/Dcm2Bids' , session = '' , clobber = False , forceDcm2niix = False , log_level = 'WARNING' , ** _ )","title":"Dcm2bids"},{"location":"reference/dcm2bids/dcm2bids/#attributes","text":"Name Type Description Default dicom_dir str or list A list of folder with dicoms to convert None participant str Label of your participant None config path Path to a dcm2bids configuration file None output_dir path Path to the BIDS base folder None session str Optional label of a session None clobber boolean Overwrite file if already in BIDS folder None forceDcm2niix boolean Forces a cleaning of a previous execution of dcm2niix None log_level str logging level None View Source class Dcm2bids(object): \"\"\" Object to handle dcm2bids execution steps Args: dicom_dir (str or list): A list of folder with dicoms to convert participant (str): Label of your participant config (path): Path to a dcm2bids configuration file output_dir (path): Path to the BIDS base folder session (str): Optional label of a session clobber (boolean): Overwrite file if already in BIDS folder forceDcm2niix (boolean): Forces a cleaning of a previous execution of dcm2niix log_level (str): logging level \"\"\" def __init__( self, dicom_dir, participant, config, output_dir=DEFAULT.outputDir, session=DEFAULT.session, clobber=DEFAULT.clobber, forceDcm2niix=DEFAULT.forceDcm2niix, log_level=DEFAULT.logLevel, **_ ): self._dicomDirs = [] self.dicomDirs = dicom_dir self.bidsDir = output_dir self.config = load_json(config) self.participant = Participant(participant, session) self.clobber = clobber self.forceDcm2niix = forceDcm2niix self.logLevel = log_level # logging setup self.set_logger() self.logger.info(\"--- dcm2bids start ---\") self.logger.info(\"OS:version: %s\", platform.platform()) self.logger.info(\"python:version: %s\", sys.version.replace(\"\\n\", \"\")) self.logger.info(\"dcm2bids:version: %s\", __version__) self.logger.info(\"dcm2niix:version: %s\", dcm2niix_version()) self.logger.info(\"participant: %s\", self.participant.name) self.logger.info(\"session: %s\", self.participant.session) self.logger.info(\"config: %s\", os.path.realpath(config)) self.logger.info(\"BIDS directory: %s\", os.path.realpath(output_dir)) @property def dicomDirs(self): \"\"\"List of DICOMs directories\"\"\" return self._dicomDirs @dicomDirs.setter def dicomDirs(self, value): if isinstance(value, list): dicom_dirs = value else: dicom_dirs = [value] dir_not_found = [] for _dir in dicom_dirs: if os.path.isdir(_dir): pass else: dir_not_found.append(_dir) if dir_not_found: raise FileNotFoundError(dir_not_found) self._dicomDirs = dicom_dirs def set_logger(self): \"\"\" Set a basic logger\"\"\" logDir = os.path.join(self.bidsDir, DEFAULT.tmpDirName, \"log\") logFile = os.path.join( logDir, \"{}_{}.log\".format( self.participant.prefix, datetime.now().isoformat().replace(\":\", \"\") ), ) # os.makedirs(logdir, exist_ok=True) # python2 compatibility if not os.path.exists(logDir): os.makedirs(logDir) setup_logging(self.logLevel, logFile) self.logger = logging.getLogger(__name__) def run(self): \"\"\"Run dcm2bids\"\"\" dcm2niix = Dcm2niix( self.dicomDirs, self.bidsDir, self.participant, self.config.get(\"dcm2niixOptions\", DEFAULT.dcm2niixOptions), ) dcm2niix.run(self.forceDcm2niix) sidecars = [] for filename in dcm2niix.sidecarFiles: sidecars.append( Sidecar(filename, self.config.get(\"compKeys\", DEFAULT.compKeys)) ) sidecars = sorted(sidecars) parser = SidecarPairing( sidecars, self.config[\"descriptions\"], self.config.get(\"searchMethod\", DEFAULT.searchMethod), self.config.get(\"caseSensitive\", DEFAULT.caseSensitive) ) parser.build_graph() parser.build_acquisitions(self.participant) parser.find_runs() self.logger.info(\"moving acquisitions into BIDS folder\") for acq in parser.acquisitions: self.move(acq) check_latest() check_latest(\"dcm2niix\") def move(self, acquisition): \"\"\"Move an acquisition to BIDS format\"\"\" for srcFile in glob(acquisition.srcRoot + \".*\"): _, ext = splitext_(srcFile) dstFile = os.path.join(self.bidsDir, acquisition.dstRoot + ext) # os.makedirs(os.path.dirname(dstFile), exist_ok=True) # python2 compatibility if not os.path.exists(os.path.dirname(dstFile)): os.makedirs(os.path.dirname(dstFile)) # checking if destination file exists if os.path.isfile(dstFile): self.logger.info(\"'%s' already exists\", dstFile) if self.clobber: self.logger.info(\"Overwriting because of 'clobber' option\") else: self.logger.info(\"Use clobber option to overwrite\") continue # it's an anat nifti file and the user using a deface script if ( self.config.get(\"defaceTpl\") and acquisition.dataType == \"anat\" and \".nii\" in ext ): try: os.remove(dstFile) except FileNotFoundError: pass defaceTpl = self.config.get(\"defaceTpl\") cmd = defaceTpl.format(srcFile=srcFile, dstFile=dstFile) run_shell_command(cmd) # use elif ext == \".json\": data = acquisition.dstSidecarData(self.config[\"descriptions\"]) save_json(dstFile, data) os.remove(srcFile) # just move else: os.rename(srcFile, dstFile)","title":"Attributes"},{"location":"reference/dcm2bids/dcm2bids/#instance-variables","text":"dicomDirs List of DICOMs directories","title":"Instance variables"},{"location":"reference/dcm2bids/dcm2bids/#methods","text":"","title":"Methods"},{"location":"reference/dcm2bids/dcm2bids/#move","text":"def move ( self , acquisition ) Move an acquisition to BIDS format View Source def move(self, acquisition): \"\"\"Move an acquisition to BIDS format\"\"\" for srcFile in glob(acquisition.srcRoot + \".*\"): _, ext = splitext_(srcFile) dstFile = os.path.join(self.bidsDir, acquisition.dstRoot + ext) # os.makedirs(os.path.dirname(dstFile), exist_ok=True) # python2 compatibility if not os.path.exists(os.path.dirname(dstFile)): os.makedirs(os.path.dirname(dstFile)) # checking if destination file exists if os.path.isfile(dstFile): self.logger.info(\"'%s' already exists\", dstFile) if self.clobber: self.logger.info(\"Overwriting because of 'clobber' option\") else: self.logger.info(\"Use clobber option to overwrite\") continue # it's an anat nifti file and the user using a deface script if ( self.config.get(\"defaceTpl\") and acquisition.dataType == \"anat\" and \".nii\" in ext ): try: os.remove(dstFile) except FileNotFoundError: pass defaceTpl = self.config.get(\"defaceTpl\") cmd = defaceTpl.format(srcFile=srcFile, dstFile=dstFile) run_shell_command(cmd) # use elif ext == \".json\": data = acquisition.dstSidecarData(self.config[\"descriptions\"]) save_json(dstFile, data) os.remove(srcFile) # just move else: os.rename(srcFile, dstFile)","title":"move"},{"location":"reference/dcm2bids/dcm2bids/#run","text":"def run ( self ) Run dcm2bids View Source def run(self): \"\"\"Run dcm2bids\"\"\" dcm2niix = Dcm2niix( self.dicomDirs, self.bidsDir, self.participant, self.config.get(\"dcm2niixOptions\", DEFAULT.dcm2niixOptions), ) dcm2niix.run(self.forceDcm2niix) sidecars = [] for filename in dcm2niix.sidecarFiles: sidecars.append( Sidecar(filename, self.config.get(\"compKeys\", DEFAULT.compKeys)) ) sidecars = sorted(sidecars) parser = SidecarPairing( sidecars, self.config[\"descriptions\"], self.config.get(\"searchMethod\", DEFAULT.searchMethod), self.config.get(\"caseSensitive\", DEFAULT.caseSensitive) ) parser.build_graph() parser.build_acquisitions(self.participant) parser.find_runs() self.logger.info(\"moving acquisitions into BIDS folder\") for acq in parser.acquisitions: self.move(acq) check_latest() check_latest(\"dcm2niix\")","title":"run"},{"location":"reference/dcm2bids/dcm2bids/#set_logger","text":"def set_logger ( self ) Set a basic logger View Source def set_logger(self): \"\"\" Set a basic logger\"\"\" logDir = os.path.join(self.bidsDir, DEFAULT.tmpDirName, \"log\") logFile = os.path.join( logDir, \"{}_{}.log\".format( self.participant.prefix, datetime.now().isoformat().replace(\":\", \"\") ), ) # os.makedirs(logdir, exist_ok=True) # python2 compatibility if not os.path.exists(logDir): os.makedirs(logDir) setup_logging(self.logLevel, logFile) self.logger = logging.getLogger(__name__)","title":"set_logger"},{"location":"reference/dcm2bids/dcm2niix/","text":"Module dcm2bids.dcm2niix Dcm2niix class None View Source # -*- coding: utf-8 -*- \"\"\"Dcm2niix class\"\"\" import logging import os import shutil from glob import glob from .utils import DEFAULT, run_shell_command class Dcm2niix(object): \"\"\" Object to handle dcm2niix execution Args: dicomDirs (list): A list of folder with dicoms to convert bidsDir (str): A path to the root BIDS directory participant: Optional Participant object options (str): Optional arguments for dcm2niix Properties: sidecars (list): A list of sidecar path created by dcm2niix \"\"\" def __init__( self, dicomDirs, bidsDir, participant=None, options=DEFAULT.dcm2niixOptions ): self.logger = logging.getLogger(__name__) self.sidecarsFiles = [] self.dicomDirs = dicomDirs self.bidsDir = bidsDir self.participant = participant self.options = options @property def outputDir(self): \"\"\" Returns: A directory to save all the output files of dcm2niix \"\"\" if self.participant: tmpDir = self.participant.prefix else: tmpDir = DEFAULT.helperDir return os.path.join(self.bidsDir, DEFAULT.tmpDirName, tmpDir) def run(self, force=False): \"\"\" Run dcm2niix if necessary Args: force (boolean): Forces a cleaning of a previous execution of dcm2niix Sets: sidecarsFiles (list): A list of sidecar path created by dcm2niix \"\"\" try: oldOutput = os.listdir(self.outputDir) != [] except: oldOutput = False if oldOutput and force: self.logger.warning(\"Previous dcm2niix directory output found:\") self.logger.warning(self.outputDir) self.logger.warning(\"'force' argument is set to True\") self.logger.warning(\"Cleaning the previous directory and running dcm2niix\") shutil.rmtree(self.outputDir, ignore_errors=True) # os.makedirs(self.outputDir, exist_ok=True) # python2 compatibility if not os.path.exists(self.outputDir): os.makedirs(self.outputDir) self.execute() elif oldOutput: self.logger.warning(\"Previous dcm2niix directory output found:\") self.logger.warning(self.outputDir) self.logger.warning(\"Use --forceDcm2niix to rerun dcm2niix\") else: # os.makedirs(self.outputDir, exist_ok=True) # python2 compatibility if not os.path.exists(self.outputDir): os.makedirs(self.outputDir) self.execute() self.sidecarFiles = glob(os.path.join(self.outputDir, \"*.json\")) def execute(self): \"\"\" Execute dcm2niix for each directory in dicomDirs \"\"\" for dicomDir in self.dicomDirs: commandTpl = \"dcm2niix {} -o {} {}\" cmd = commandTpl.format(self.options, self.outputDir, dicomDir) output = run_shell_command(cmd) try: output = output.decode() except: pass self.logger.debug(\"\\n%s\", output) self.logger.info(\"Check log file for dcm2niix output\") Classes Dcm2niix class Dcm2niix ( dicomDirs , bidsDir , participant = None , options = \"-b y -ba y -z y -f ' %3s _ %f _%p_%t'\" ) Attributes Name Type Description Default dicomDirs list A list of folder with dicoms to convert None bidsDir str A path to the root BIDS directory None participant None Optional Participant object None options str Optional arguments for dcm2niix Properties: None sidecars list A list of sidecar path created by dcm2niix None View Source class Dcm2niix(object): \"\"\" Object to handle dcm2niix execution Args: dicomDirs (list): A list of folder with dicoms to convert bidsDir (str): A path to the root BIDS directory participant: Optional Participant object options (str): Optional arguments for dcm2niix Properties: sidecars (list): A list of sidecar path created by dcm2niix \"\"\" def __init__( self, dicomDirs, bidsDir, participant=None, options=DEFAULT.dcm2niixOptions ): self.logger = logging.getLogger(__name__) self.sidecarsFiles = [] self.dicomDirs = dicomDirs self.bidsDir = bidsDir self.participant = participant self.options = options @property def outputDir(self): \"\"\" Returns: A directory to save all the output files of dcm2niix \"\"\" if self.participant: tmpDir = self.participant.prefix else: tmpDir = DEFAULT.helperDir return os.path.join(self.bidsDir, DEFAULT.tmpDirName, tmpDir) def run(self, force=False): \"\"\" Run dcm2niix if necessary Args: force (boolean): Forces a cleaning of a previous execution of dcm2niix Sets: sidecarsFiles (list): A list of sidecar path created by dcm2niix \"\"\" try: oldOutput = os.listdir(self.outputDir) != [] except: oldOutput = False if oldOutput and force: self.logger.warning(\"Previous dcm2niix directory output found:\") self.logger.warning(self.outputDir) self.logger.warning(\"'force' argument is set to True\") self.logger.warning(\"Cleaning the previous directory and running dcm2niix\") shutil.rmtree(self.outputDir, ignore_errors=True) # os.makedirs(self.outputDir, exist_ok=True) # python2 compatibility if not os.path.exists(self.outputDir): os.makedirs(self.outputDir) self.execute() elif oldOutput: self.logger.warning(\"Previous dcm2niix directory output found:\") self.logger.warning(self.outputDir) self.logger.warning(\"Use --forceDcm2niix to rerun dcm2niix\") else: # os.makedirs(self.outputDir, exist_ok=True) # python2 compatibility if not os.path.exists(self.outputDir): os.makedirs(self.outputDir) self.execute() self.sidecarFiles = glob(os.path.join(self.outputDir, \"*.json\")) def execute(self): \"\"\" Execute dcm2niix for each directory in dicomDirs \"\"\" for dicomDir in self.dicomDirs: commandTpl = \"dcm2niix {} -o {} {}\" cmd = commandTpl.format(self.options, self.outputDir, dicomDir) output = run_shell_command(cmd) try: output = output.decode() except: pass self.logger.debug(\"\\n%s\", output) self.logger.info(\"Check log file for dcm2niix output\") Instance variables outputDir Returns: A directory to save all the output files of dcm2niix Methods execute def execute ( self ) Execute dcm2niix for each directory in dicomDirs View Source def execute(self): \"\"\" Execute dcm2niix for each directory in dicomDirs \"\"\" for dicomDir in self.dicomDirs: commandTpl = \"dcm2niix {} -o {} {}\" cmd = commandTpl.format(self.options, self.outputDir, dicomDir) output = run_shell_command(cmd) try: output = output.decode() except: pass self.logger.debug(\"\\n%s\", output) self.logger.info(\"Check log file for dcm2niix output\") run def run ( self , force = False ) Run dcm2niix if necessary Parameters: Name Type Description Default force boolean Forces a cleaning of a previous execution of dcm2niix Sets: | None | | sidecarsFiles | list | A list of sidecar path created by dcm2niix | None | View Source def run(self, force=False): \"\"\" Run dcm2niix if necessary Args: force (boolean): Forces a cleaning of a previous execution of dcm2niix Sets: sidecarsFiles (list): A list of sidecar path created by dcm2niix \"\"\" try: oldOutput = os.listdir(self.outputDir) != [] except: oldOutput = False if oldOutput and force: self.logger.warning(\"Previous dcm2niix directory output found:\") self.logger.warning(self.outputDir) self.logger.warning(\"'force' argument is set to True\") self.logger.warning(\"Cleaning the previous directory and running dcm2niix\") shutil.rmtree(self.outputDir, ignore_errors=True) # os.makedirs(self.outputDir, exist_ok=True) # python2 compatibility if not os.path.exists(self.outputDir): os.makedirs(self.outputDir) self.execute() elif oldOutput: self.logger.warning(\"Previous dcm2niix directory output found:\") self.logger.warning(self.outputDir) self.logger.warning(\"Use --forceDcm2niix to rerun dcm2niix\") else: # os.makedirs(self.outputDir, exist_ok=True) # python2 compatibility if not os.path.exists(self.outputDir): os.makedirs(self.outputDir) self.execute() self.sidecarFiles = glob(os.path.join(self.outputDir, \"*.json\"))","title":"Dcm2Niix"},{"location":"reference/dcm2bids/dcm2niix/#module-dcm2bidsdcm2niix","text":"Dcm2niix class None View Source # -*- coding: utf-8 -*- \"\"\"Dcm2niix class\"\"\" import logging import os import shutil from glob import glob from .utils import DEFAULT, run_shell_command class Dcm2niix(object): \"\"\" Object to handle dcm2niix execution Args: dicomDirs (list): A list of folder with dicoms to convert bidsDir (str): A path to the root BIDS directory participant: Optional Participant object options (str): Optional arguments for dcm2niix Properties: sidecars (list): A list of sidecar path created by dcm2niix \"\"\" def __init__( self, dicomDirs, bidsDir, participant=None, options=DEFAULT.dcm2niixOptions ): self.logger = logging.getLogger(__name__) self.sidecarsFiles = [] self.dicomDirs = dicomDirs self.bidsDir = bidsDir self.participant = participant self.options = options @property def outputDir(self): \"\"\" Returns: A directory to save all the output files of dcm2niix \"\"\" if self.participant: tmpDir = self.participant.prefix else: tmpDir = DEFAULT.helperDir return os.path.join(self.bidsDir, DEFAULT.tmpDirName, tmpDir) def run(self, force=False): \"\"\" Run dcm2niix if necessary Args: force (boolean): Forces a cleaning of a previous execution of dcm2niix Sets: sidecarsFiles (list): A list of sidecar path created by dcm2niix \"\"\" try: oldOutput = os.listdir(self.outputDir) != [] except: oldOutput = False if oldOutput and force: self.logger.warning(\"Previous dcm2niix directory output found:\") self.logger.warning(self.outputDir) self.logger.warning(\"'force' argument is set to True\") self.logger.warning(\"Cleaning the previous directory and running dcm2niix\") shutil.rmtree(self.outputDir, ignore_errors=True) # os.makedirs(self.outputDir, exist_ok=True) # python2 compatibility if not os.path.exists(self.outputDir): os.makedirs(self.outputDir) self.execute() elif oldOutput: self.logger.warning(\"Previous dcm2niix directory output found:\") self.logger.warning(self.outputDir) self.logger.warning(\"Use --forceDcm2niix to rerun dcm2niix\") else: # os.makedirs(self.outputDir, exist_ok=True) # python2 compatibility if not os.path.exists(self.outputDir): os.makedirs(self.outputDir) self.execute() self.sidecarFiles = glob(os.path.join(self.outputDir, \"*.json\")) def execute(self): \"\"\" Execute dcm2niix for each directory in dicomDirs \"\"\" for dicomDir in self.dicomDirs: commandTpl = \"dcm2niix {} -o {} {}\" cmd = commandTpl.format(self.options, self.outputDir, dicomDir) output = run_shell_command(cmd) try: output = output.decode() except: pass self.logger.debug(\"\\n%s\", output) self.logger.info(\"Check log file for dcm2niix output\")","title":"Module dcm2bids.dcm2niix"},{"location":"reference/dcm2bids/dcm2niix/#classes","text":"","title":"Classes"},{"location":"reference/dcm2bids/dcm2niix/#dcm2niix","text":"class Dcm2niix ( dicomDirs , bidsDir , participant = None , options = \"-b y -ba y -z y -f ' %3s _ %f _%p_%t'\" )","title":"Dcm2niix"},{"location":"reference/dcm2bids/dcm2niix/#attributes","text":"Name Type Description Default dicomDirs list A list of folder with dicoms to convert None bidsDir str A path to the root BIDS directory None participant None Optional Participant object None options str Optional arguments for dcm2niix Properties: None sidecars list A list of sidecar path created by dcm2niix None View Source class Dcm2niix(object): \"\"\" Object to handle dcm2niix execution Args: dicomDirs (list): A list of folder with dicoms to convert bidsDir (str): A path to the root BIDS directory participant: Optional Participant object options (str): Optional arguments for dcm2niix Properties: sidecars (list): A list of sidecar path created by dcm2niix \"\"\" def __init__( self, dicomDirs, bidsDir, participant=None, options=DEFAULT.dcm2niixOptions ): self.logger = logging.getLogger(__name__) self.sidecarsFiles = [] self.dicomDirs = dicomDirs self.bidsDir = bidsDir self.participant = participant self.options = options @property def outputDir(self): \"\"\" Returns: A directory to save all the output files of dcm2niix \"\"\" if self.participant: tmpDir = self.participant.prefix else: tmpDir = DEFAULT.helperDir return os.path.join(self.bidsDir, DEFAULT.tmpDirName, tmpDir) def run(self, force=False): \"\"\" Run dcm2niix if necessary Args: force (boolean): Forces a cleaning of a previous execution of dcm2niix Sets: sidecarsFiles (list): A list of sidecar path created by dcm2niix \"\"\" try: oldOutput = os.listdir(self.outputDir) != [] except: oldOutput = False if oldOutput and force: self.logger.warning(\"Previous dcm2niix directory output found:\") self.logger.warning(self.outputDir) self.logger.warning(\"'force' argument is set to True\") self.logger.warning(\"Cleaning the previous directory and running dcm2niix\") shutil.rmtree(self.outputDir, ignore_errors=True) # os.makedirs(self.outputDir, exist_ok=True) # python2 compatibility if not os.path.exists(self.outputDir): os.makedirs(self.outputDir) self.execute() elif oldOutput: self.logger.warning(\"Previous dcm2niix directory output found:\") self.logger.warning(self.outputDir) self.logger.warning(\"Use --forceDcm2niix to rerun dcm2niix\") else: # os.makedirs(self.outputDir, exist_ok=True) # python2 compatibility if not os.path.exists(self.outputDir): os.makedirs(self.outputDir) self.execute() self.sidecarFiles = glob(os.path.join(self.outputDir, \"*.json\")) def execute(self): \"\"\" Execute dcm2niix for each directory in dicomDirs \"\"\" for dicomDir in self.dicomDirs: commandTpl = \"dcm2niix {} -o {} {}\" cmd = commandTpl.format(self.options, self.outputDir, dicomDir) output = run_shell_command(cmd) try: output = output.decode() except: pass self.logger.debug(\"\\n%s\", output) self.logger.info(\"Check log file for dcm2niix output\")","title":"Attributes"},{"location":"reference/dcm2bids/dcm2niix/#instance-variables","text":"outputDir Returns: A directory to save all the output files of dcm2niix","title":"Instance variables"},{"location":"reference/dcm2bids/dcm2niix/#methods","text":"","title":"Methods"},{"location":"reference/dcm2bids/dcm2niix/#execute","text":"def execute ( self ) Execute dcm2niix for each directory in dicomDirs View Source def execute(self): \"\"\" Execute dcm2niix for each directory in dicomDirs \"\"\" for dicomDir in self.dicomDirs: commandTpl = \"dcm2niix {} -o {} {}\" cmd = commandTpl.format(self.options, self.outputDir, dicomDir) output = run_shell_command(cmd) try: output = output.decode() except: pass self.logger.debug(\"\\n%s\", output) self.logger.info(\"Check log file for dcm2niix output\")","title":"execute"},{"location":"reference/dcm2bids/dcm2niix/#run","text":"def run ( self , force = False ) Run dcm2niix if necessary Parameters: Name Type Description Default force boolean Forces a cleaning of a previous execution of dcm2niix Sets: | None | | sidecarsFiles | list | A list of sidecar path created by dcm2niix | None | View Source def run(self, force=False): \"\"\" Run dcm2niix if necessary Args: force (boolean): Forces a cleaning of a previous execution of dcm2niix Sets: sidecarsFiles (list): A list of sidecar path created by dcm2niix \"\"\" try: oldOutput = os.listdir(self.outputDir) != [] except: oldOutput = False if oldOutput and force: self.logger.warning(\"Previous dcm2niix directory output found:\") self.logger.warning(self.outputDir) self.logger.warning(\"'force' argument is set to True\") self.logger.warning(\"Cleaning the previous directory and running dcm2niix\") shutil.rmtree(self.outputDir, ignore_errors=True) # os.makedirs(self.outputDir, exist_ok=True) # python2 compatibility if not os.path.exists(self.outputDir): os.makedirs(self.outputDir) self.execute() elif oldOutput: self.logger.warning(\"Previous dcm2niix directory output found:\") self.logger.warning(self.outputDir) self.logger.warning(\"Use --forceDcm2niix to rerun dcm2niix\") else: # os.makedirs(self.outputDir, exist_ok=True) # python2 compatibility if not os.path.exists(self.outputDir): os.makedirs(self.outputDir) self.execute() self.sidecarFiles = glob(os.path.join(self.outputDir, \"*.json\"))","title":"run"},{"location":"reference/dcm2bids/helper/","text":"Module dcm2bids.helper helper module None View Source # -*- coding: utf-8 -*- \"\"\"helper module\"\"\" import argparse import os import sys from .dcm2niix import Dcm2niix from .utils import DEFAULT def get_arguments(): \"\"\"Load arguments for main\"\"\" parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, description=\"\", epilog=\"\"\" Documentation at https://github.com/unfmontreal/Dcm2Bids \"\"\", ) parser.add_argument( \"-d\", \"--dicom_dir\", required=True, nargs=\"+\", help=\"DICOM files directory\" ) parser.add_argument( \"-o\", \"--output_dir\", required=False, default=DEFAULT.cliOutputDir, help=\"Output BIDS directory, Default: current directory\", ) args = parser.parse_args() return args def main(): \"\"\"Let's go\"\"\" args = get_arguments() app = Dcm2niix(dicomDirs=args.dicom_dir, bidsDir=args.output_dir) rsl = app.run() print(\"Example in:\") print(os.path.join(args.output_dir, DEFAULT.tmpDirName, DEFAULT.helperDir)) return rsl if __name__ == \"__main__\": sys.exit(main()) Functions get_arguments def get_arguments ( ) Load arguments for main View Source def get_arguments(): \"\"\"Load arguments for main\"\"\" parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, description=\"\", epilog=\"\"\" Documentation at https://github.com/unfmontreal/Dcm2Bids \"\"\", ) parser.add_argument( \"-d\", \"--dicom_dir\", required=True, nargs=\"+\", help=\"DICOM files directory\" ) parser.add_argument( \"-o\", \"--output_dir\", required=False, default=DEFAULT.cliOutputDir, help=\"Output BIDS directory, Default: current directory\", ) args = parser.parse_args() return args main def main ( ) Let's go View Source def main(): \"\"\"Let's go\"\"\" args = get_arguments() app = Dcm2niix(dicomDirs=args.dicom_dir, bidsDir=args.output_dir) rsl = app.run() print(\"Example in:\") print(os.path.join(args.output_dir, DEFAULT.tmpDirName, DEFAULT.helperDir)) return rsl","title":"Helper"},{"location":"reference/dcm2bids/helper/#module-dcm2bidshelper","text":"helper module None View Source # -*- coding: utf-8 -*- \"\"\"helper module\"\"\" import argparse import os import sys from .dcm2niix import Dcm2niix from .utils import DEFAULT def get_arguments(): \"\"\"Load arguments for main\"\"\" parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, description=\"\", epilog=\"\"\" Documentation at https://github.com/unfmontreal/Dcm2Bids \"\"\", ) parser.add_argument( \"-d\", \"--dicom_dir\", required=True, nargs=\"+\", help=\"DICOM files directory\" ) parser.add_argument( \"-o\", \"--output_dir\", required=False, default=DEFAULT.cliOutputDir, help=\"Output BIDS directory, Default: current directory\", ) args = parser.parse_args() return args def main(): \"\"\"Let's go\"\"\" args = get_arguments() app = Dcm2niix(dicomDirs=args.dicom_dir, bidsDir=args.output_dir) rsl = app.run() print(\"Example in:\") print(os.path.join(args.output_dir, DEFAULT.tmpDirName, DEFAULT.helperDir)) return rsl if __name__ == \"__main__\": sys.exit(main())","title":"Module dcm2bids.helper"},{"location":"reference/dcm2bids/helper/#functions","text":"","title":"Functions"},{"location":"reference/dcm2bids/helper/#get_arguments","text":"def get_arguments ( ) Load arguments for main View Source def get_arguments(): \"\"\"Load arguments for main\"\"\" parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, description=\"\", epilog=\"\"\" Documentation at https://github.com/unfmontreal/Dcm2Bids \"\"\", ) parser.add_argument( \"-d\", \"--dicom_dir\", required=True, nargs=\"+\", help=\"DICOM files directory\" ) parser.add_argument( \"-o\", \"--output_dir\", required=False, default=DEFAULT.cliOutputDir, help=\"Output BIDS directory, Default: current directory\", ) args = parser.parse_args() return args","title":"get_arguments"},{"location":"reference/dcm2bids/helper/#main","text":"def main ( ) Let's go View Source def main(): \"\"\"Let's go\"\"\" args = get_arguments() app = Dcm2niix(dicomDirs=args.dicom_dir, bidsDir=args.output_dir) rsl = app.run() print(\"Example in:\") print(os.path.join(args.output_dir, DEFAULT.tmpDirName, DEFAULT.helperDir)) return rsl","title":"main"},{"location":"reference/dcm2bids/logger/","text":"Module dcm2bids.logger Setup logging configuration None View Source # -*- coding: utf-8 -*- \"\"\"Setup logging configuration\"\"\" import logging def setup_logging(logLevel, logFile=None): \"\"\" Setup logging configuration\"\"\" logging.basicConfig() logger = logging.getLogger() # Check level level = getattr(logging, logLevel.upper(), None) if not isinstance(level, int): raise ValueError(\"Invalid log level: {}\".format(logLevel)) logger.setLevel(level) # Set FileHandler if logFile: formatter = logging.Formatter(logging.BASIC_FORMAT) handler = logging.FileHandler(logFile) handler.setFormatter(formatter) handler.setLevel(\"DEBUG\") logger.addHandler(handler) Functions setup_logging def setup_logging ( logLevel , logFile = None ) Setup logging configuration View Source def setup_logging(logLevel, logFile=None): \"\"\" Setup logging configuration\"\"\" logging.basicConfig() logger = logging.getLogger() # Check level level = getattr(logging, logLevel.upper(), None) if not isinstance(level, int): raise ValueError(\"Invalid log level: {}\".format(logLevel)) logger.setLevel(level) # Set FileHandler if logFile: formatter = logging.Formatter(logging.BASIC_FORMAT) handler = logging.FileHandler(logFile) handler.setFormatter(formatter) handler.setLevel(\"DEBUG\") logger.addHandler(handler)","title":"Logger"},{"location":"reference/dcm2bids/logger/#module-dcm2bidslogger","text":"Setup logging configuration None View Source # -*- coding: utf-8 -*- \"\"\"Setup logging configuration\"\"\" import logging def setup_logging(logLevel, logFile=None): \"\"\" Setup logging configuration\"\"\" logging.basicConfig() logger = logging.getLogger() # Check level level = getattr(logging, logLevel.upper(), None) if not isinstance(level, int): raise ValueError(\"Invalid log level: {}\".format(logLevel)) logger.setLevel(level) # Set FileHandler if logFile: formatter = logging.Formatter(logging.BASIC_FORMAT) handler = logging.FileHandler(logFile) handler.setFormatter(formatter) handler.setLevel(\"DEBUG\") logger.addHandler(handler)","title":"Module dcm2bids.logger"},{"location":"reference/dcm2bids/logger/#functions","text":"","title":"Functions"},{"location":"reference/dcm2bids/logger/#setup_logging","text":"def setup_logging ( logLevel , logFile = None ) Setup logging configuration View Source def setup_logging(logLevel, logFile=None): \"\"\" Setup logging configuration\"\"\" logging.basicConfig() logger = logging.getLogger() # Check level level = getattr(logging, logLevel.upper(), None) if not isinstance(level, int): raise ValueError(\"Invalid log level: {}\".format(logLevel)) logger.setLevel(level) # Set FileHandler if logFile: formatter = logging.Formatter(logging.BASIC_FORMAT) handler = logging.FileHandler(logFile) handler.setFormatter(formatter) handler.setLevel(\"DEBUG\") logger.addHandler(handler)","title":"setup_logging"},{"location":"reference/dcm2bids/scaffold/","text":"Module dcm2bids.scaffold scaffold module None View Source \"\"\"scaffold module\"\"\" import sys import argparse import datetime import os import shutil if sys.version_info >= (3,7,0): import importlib.resources as resources else: # backport: https://pypi.org/project/importlib-resources/ # TODO: drop this when py3.6 is end-of-life import importlib_resources as resources from ..utils import write_txt def _get_arguments(): \"\"\"Load arguments for main\"\"\" parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, description=\"\"\" Create basic BIDS files and directories \"\"\", epilog=\"\"\" Documentation at https://github.com/unfmontreal/Dcm2Bids \"\"\", ) parser.add_argument( \"-o\", \"--output_dir\", required=False, default=os.getcwd(), help=\"Output BIDS directory, Default: current directory\", ) args = parser.parse_args() return args def scaffold(): \"\"\"scaffold entry point\"\"\" args = _get_arguments() for _ in [\"code\", \"derivatives\", \"sourcedata\"]: os.makedirs(os.path.join(args.output_dir, _), exist_ok=True) for _ in [ \"dataset_description.json\", \"participants.json\", \"participants.tsv\", \"README\", ]: dest = os.path.join(args.output_dir, _) with resources.path(__name__, _) as src: shutil.copyfile(src, dest) with resources.path(__name__, \"CHANGES\") as changes_template: with open(changes_template) as _: data = _.read().format(datetime.date.today().strftime(\"%Y-%m-%d\")) write_txt( os.path.join(args.output_dir, \"CHANGES\"), data.split(\"\\n\")[:-1], ) Functions scaffold def scaffold ( ) scaffold entry point View Source def scaffold(): \"\"\"scaffold entry point\"\"\" args = _get_arguments() for _ in [\"code\", \"derivatives\", \"sourcedata\"]: os.makedirs(os.path.join(args.output_dir, _), exist_ok=True) for _ in [ \"dataset_description.json\", \"participants.json\", \"participants.tsv\", \"README\", ]: dest = os.path.join(args.output_dir, _) with resources.path(__name__, _) as src: shutil.copyfile(src, dest) with resources.path(__name__, \"CHANGES\") as changes_template: with open(changes_template) as _: data = _.read().format(datetime.date.today().strftime(\"%Y-%m-%d\")) write_txt( os.path.join(args.output_dir, \"CHANGES\"), data.split(\"\\n\")[:-1], )","title":"Scaffold"},{"location":"reference/dcm2bids/scaffold/#module-dcm2bidsscaffold","text":"scaffold module None View Source \"\"\"scaffold module\"\"\" import sys import argparse import datetime import os import shutil if sys.version_info >= (3,7,0): import importlib.resources as resources else: # backport: https://pypi.org/project/importlib-resources/ # TODO: drop this when py3.6 is end-of-life import importlib_resources as resources from ..utils import write_txt def _get_arguments(): \"\"\"Load arguments for main\"\"\" parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, description=\"\"\" Create basic BIDS files and directories \"\"\", epilog=\"\"\" Documentation at https://github.com/unfmontreal/Dcm2Bids \"\"\", ) parser.add_argument( \"-o\", \"--output_dir\", required=False, default=os.getcwd(), help=\"Output BIDS directory, Default: current directory\", ) args = parser.parse_args() return args def scaffold(): \"\"\"scaffold entry point\"\"\" args = _get_arguments() for _ in [\"code\", \"derivatives\", \"sourcedata\"]: os.makedirs(os.path.join(args.output_dir, _), exist_ok=True) for _ in [ \"dataset_description.json\", \"participants.json\", \"participants.tsv\", \"README\", ]: dest = os.path.join(args.output_dir, _) with resources.path(__name__, _) as src: shutil.copyfile(src, dest) with resources.path(__name__, \"CHANGES\") as changes_template: with open(changes_template) as _: data = _.read().format(datetime.date.today().strftime(\"%Y-%m-%d\")) write_txt( os.path.join(args.output_dir, \"CHANGES\"), data.split(\"\\n\")[:-1], )","title":"Module dcm2bids.scaffold"},{"location":"reference/dcm2bids/scaffold/#functions","text":"","title":"Functions"},{"location":"reference/dcm2bids/scaffold/#scaffold","text":"def scaffold ( ) scaffold entry point View Source def scaffold(): \"\"\"scaffold entry point\"\"\" args = _get_arguments() for _ in [\"code\", \"derivatives\", \"sourcedata\"]: os.makedirs(os.path.join(args.output_dir, _), exist_ok=True) for _ in [ \"dataset_description.json\", \"participants.json\", \"participants.tsv\", \"README\", ]: dest = os.path.join(args.output_dir, _) with resources.path(__name__, _) as src: shutil.copyfile(src, dest) with resources.path(__name__, \"CHANGES\") as changes_template: with open(changes_template) as _: data = _.read().format(datetime.date.today().strftime(\"%Y-%m-%d\")) write_txt( os.path.join(args.output_dir, \"CHANGES\"), data.split(\"\\n\")[:-1], )","title":"scaffold"},{"location":"reference/dcm2bids/sidecar/","text":"Module dcm2bids.sidecar sidecars classes None View Source # -*- coding: utf-8 -*- \"\"\"sidecars classes\"\"\" import itertools import logging import os import re from collections import defaultdict, OrderedDict from fnmatch import fnmatch from future.utils import iteritems from .structure import Acquisition from .utils import DEFAULT, load_json, splitext_ class Sidecar(object): \"\"\" A sidecar object Args: filename (str): Path of a JSON sidecar keyComp (list): A list of keys from the JSON sidecar to compare sidecars default=[\"SeriesNumber\",\"AcquisitionTime\",\"SideCarFilename\"] \"\"\" def __init__(self, filename, compKeys=DEFAULT.compKeys): self._origData = {} self._data = {} self.filename = filename self.root, _ = splitext_(filename) self.data = filename self.compKeys = compKeys def __lt__(self, other): lts = [] for key in self.compKeys: try: if all(key in d for d in (self.data, other.data)): if self.data.get(key) == other.data.get(key): lts.append(None) else: lts.append(self.data.get(key) < other.data.get(key)) else: lts.append(None) except: lts.append(None) for lt in lts: if lt is not None: return lt def __eq__(self, other): return self.data == other.data def __hash__(self): return hash(self.filename) @property def origData(self): return self._origData @property def data(self): return self._data @data.setter def data(self, filename): \"\"\" Args: filename (path): path of a JSON file Return: A dictionnary of the JSON content plus the SidecarFilename \"\"\" try: data = load_json(filename) except: data = {} self._origData = data.copy() data[\"SidecarFilename\"] = os.path.basename(filename) self._data = data class SidecarPairing(object): \"\"\" Args: sidecars (list): List of Sidecar objects descriptions (list): List of dictionnaries describing acquisitions \"\"\" def __init__(self, sidecars, descriptions, searchMethod=DEFAULT.searchMethod, caseSensitive=DEFAULT.caseSensitive): self.logger = logging.getLogger(__name__) self._searchMethod = \"\" self.graph = OrderedDict() self.aquisitions = [] self.sidecars = sidecars self.descriptions = descriptions self.searchMethod = searchMethod self.caseSensitive = caseSensitive @property def searchMethod(self): return self._searchMethod @searchMethod.setter def searchMethod(self, value): \"\"\" Checks if the search method is implemented Warns the user if not and fall back to default \"\"\" if value in DEFAULT.searchMethodChoices: self._searchMethod = value else: self._searchMethod = DEFAULT.searchMethod self.logger.warning(\"'%s' is not a search method implemented\", value) self.logger.warning( \"Falling back to default: %s\", DEFAULT.searchMethod ) self.logger.warning( \"Search methods implemented: %s\", DEFAULT.searchMethodChoices ) @property def caseSensitive(self): return self._caseSensitive @caseSensitive.setter def caseSensitive(self, value): if isinstance(value, bool): self._caseSensitive = value else: self._caseSensitive = DEFAULT.caseSensitive self.logger.warning(\"'%s' is not a boolean\", value) self.logger.warning( \"Falling back to default: %s\", DEFAULT.caseSensitive ) self.logger.warning( \"Search methods implemented: %s\", DEFAULT.caseSensitive ) def build_graph(self): \"\"\" Test all the possible links between the list of sidecars and the description dictionnaries and build a graph from it The graph is in a OrderedDict object. The keys are the Sidecars and the values are a list of possible descriptions Returns: A graph (OrderedDict) \"\"\" graph = OrderedDict((_, []) for _ in self.sidecars) possibleLinks = itertools.product(self.sidecars, self.descriptions) for sidecar, description in possibleLinks: criteria = description.get(\"criteria\", None) if criteria and self.isLink(sidecar.data, criteria): graph[sidecar].append(description) self.graph = graph return graph def isLink(self, data, criteria): \"\"\" Args: data (dict): Dictionnary data of a sidecar criteria (dict): Dictionnary criteria Returns: boolean \"\"\" def compare(name, pattern): if self.searchMethod == \"re\": return bool(re.search(pattern, name)) else: name = str(name) pattern = str(pattern) if not self.caseSensitive: name = name.lower() pattern = pattern.lower() return fnmatch(name, pattern) result = [] for tag, pattern in iteritems(criteria): name = data.get(tag, '')# or '' if isinstance(name, list): try: subResult = [len(name) == len(pattern), isinstance(pattern, list)] for subName, subPattern in zip(name, pattern): subResult.append(compare(subName, subPattern)) except: subResult = [False] result.append(all(subResult)) else: result.append(compare(name, pattern)) return all(result) def build_acquisitions(self, participant): \"\"\" Args: participant (Participant): Participant object to create acquisitions Returns: A list of acquisition objects \"\"\" acquisitions = [] self.logger.info(\"Sidecars pairing:\") for sidecar, descriptions in iteritems(self.graph): sidecarName = os.path.basename(sidecar.root) # only one description for the sidecar if len(descriptions) == 1: desc = descriptions[0] acq = Acquisition(participant, srcSidecar=sidecar, **desc) acquisitions.append(acq) self.logger.info(\"%s <- %s\", acq.suffix, sidecarName) # sidecar with no link elif len(descriptions) == 0: self.logger.info(\"No Pairing <- %s\", sidecarName) # sidecar with several links else: self.logger.warning(\"Several Pairing <- %s\", sidecarName) for desc in descriptions: acq = Acquisition(participant, **desc) self.logger.warning(\" -> %s\", acq.suffix) self.acquisitions = acquisitions return acquisitions def find_runs(self): \"\"\" Check if there is duplicate destination roots in the acquisitions and add '_run-' to the customLabels of the acquisition \"\"\" def duplicates(seq): \"\"\" Find duplicate items in a list Args: seq (list) Yield: A tuple of 2 items (item, list of index) ref: http://stackoverflow.com/a/5419576 \"\"\" tally = defaultdict(list) for i, item in enumerate(seq): tally[item].append(i) for key, locs in iteritems(tally): if len(locs) > 1: yield key, locs dstRoots = [_.dstRoot for _ in self.acquisitions] for dstRoot, dup in duplicates(dstRoots): self.logger.info(\"%s has %s runs\", dstRoot, len(dup)) self.logger.info(\"Adding 'run' information to the acquisition\") for runNum, acqInd in enumerate(dup): runStr = DEFAULT.runTpl.format(runNum + 1) self.acquisitions[acqInd].customLabels += runStr Classes Sidecar class Sidecar ( filename , compKeys = [ 'SeriesNumber' , 'AcquisitionTime' , 'SidecarFilename' ] ) Attributes Name Type Description Default filename str Path of a JSON sidecar None keyComp list A list of keys from the JSON sidecar to compare sidecars default=[\"SeriesNumber\",\"AcquisitionTime\",\"SideCarFilename\"] None View Source class Sidecar(object): \"\"\" A sidecar object Args: filename (str): Path of a JSON sidecar keyComp (list): A list of keys from the JSON sidecar to compare sidecars default=[\"SeriesNumber\",\"AcquisitionTime\",\"SideCarFilename\"] \"\"\" def __init__(self, filename, compKeys=DEFAULT.compKeys): self._origData = {} self._data = {} self.filename = filename self.root, _ = splitext_(filename) self.data = filename self.compKeys = compKeys def __lt__(self, other): lts = [] for key in self.compKeys: try: if all(key in d for d in (self.data, other.data)): if self.data.get(key) == other.data.get(key): lts.append(None) else: lts.append(self.data.get(key) < other.data.get(key)) else: lts.append(None) except: lts.append(None) for lt in lts: if lt is not None: return lt def __eq__(self, other): return self.data == other.data def __hash__(self): return hash(self.filename) @property def origData(self): return self._origData @property def data(self): return self._data @data.setter def data(self, filename): \"\"\" Args: filename (path): path of a JSON file Return: A dictionnary of the JSON content plus the SidecarFilename \"\"\" try: data = load_json(filename) except: data = {} self._origData = data.copy() data[\"SidecarFilename\"] = os.path.basename(filename) self._data = data Instance variables data origData SidecarPairing class SidecarPairing ( sidecars , descriptions , searchMethod = 'fnmatch' , caseSensitive = True ) View Source class SidecarPairing(object): \"\"\" Args: sidecars (list): List of Sidecar objects descriptions (list): List of dictionnaries describing acquisitions \"\"\" def __init__(self, sidecars, descriptions, searchMethod=DEFAULT.searchMethod, caseSensitive=DEFAULT.caseSensitive): self.logger = logging.getLogger(__name__) self._searchMethod = \"\" self.graph = OrderedDict() self.aquisitions = [] self.sidecars = sidecars self.descriptions = descriptions self.searchMethod = searchMethod self.caseSensitive = caseSensitive @property def searchMethod(self): return self._searchMethod @searchMethod.setter def searchMethod(self, value): \"\"\" Checks if the search method is implemented Warns the user if not and fall back to default \"\"\" if value in DEFAULT.searchMethodChoices: self._searchMethod = value else: self._searchMethod = DEFAULT.searchMethod self.logger.warning(\"'%s' is not a search method implemented\", value) self.logger.warning( \"Falling back to default: %s\", DEFAULT.searchMethod ) self.logger.warning( \"Search methods implemented: %s\", DEFAULT.searchMethodChoices ) @property def caseSensitive(self): return self._caseSensitive @caseSensitive.setter def caseSensitive(self, value): if isinstance(value, bool): self._caseSensitive = value else: self._caseSensitive = DEFAULT.caseSensitive self.logger.warning(\"'%s' is not a boolean\", value) self.logger.warning( \"Falling back to default: %s\", DEFAULT.caseSensitive ) self.logger.warning( \"Search methods implemented: %s\", DEFAULT.caseSensitive ) def build_graph(self): \"\"\" Test all the possible links between the list of sidecars and the description dictionnaries and build a graph from it The graph is in a OrderedDict object. The keys are the Sidecars and the values are a list of possible descriptions Returns: A graph (OrderedDict) \"\"\" graph = OrderedDict((_, []) for _ in self.sidecars) possibleLinks = itertools.product(self.sidecars, self.descriptions) for sidecar, description in possibleLinks: criteria = description.get(\"criteria\", None) if criteria and self.isLink(sidecar.data, criteria): graph[sidecar].append(description) self.graph = graph return graph def isLink(self, data, criteria): \"\"\" Args: data (dict): Dictionnary data of a sidecar criteria (dict): Dictionnary criteria Returns: boolean \"\"\" def compare(name, pattern): if self.searchMethod == \"re\": return bool(re.search(pattern, name)) else: name = str(name) pattern = str(pattern) if not self.caseSensitive: name = name.lower() pattern = pattern.lower() return fnmatch(name, pattern) result = [] for tag, pattern in iteritems(criteria): name = data.get(tag, '')# or '' if isinstance(name, list): try: subResult = [len(name) == len(pattern), isinstance(pattern, list)] for subName, subPattern in zip(name, pattern): subResult.append(compare(subName, subPattern)) except: subResult = [False] result.append(all(subResult)) else: result.append(compare(name, pattern)) return all(result) def build_acquisitions(self, participant): \"\"\" Args: participant (Participant): Participant object to create acquisitions Returns: A list of acquisition objects \"\"\" acquisitions = [] self.logger.info(\"Sidecars pairing:\") for sidecar, descriptions in iteritems(self.graph): sidecarName = os.path.basename(sidecar.root) # only one description for the sidecar if len(descriptions) == 1: desc = descriptions[0] acq = Acquisition(participant, srcSidecar=sidecar, **desc) acquisitions.append(acq) self.logger.info(\"%s <- %s\", acq.suffix, sidecarName) # sidecar with no link elif len(descriptions) == 0: self.logger.info(\"No Pairing <- %s\", sidecarName) # sidecar with several links else: self.logger.warning(\"Several Pairing <- %s\", sidecarName) for desc in descriptions: acq = Acquisition(participant, **desc) self.logger.warning(\" -> %s\", acq.suffix) self.acquisitions = acquisitions return acquisitions def find_runs(self): \"\"\" Check if there is duplicate destination roots in the acquisitions and add '_run-' to the customLabels of the acquisition \"\"\" def duplicates(seq): \"\"\" Find duplicate items in a list Args: seq (list) Yield: A tuple of 2 items (item, list of index) ref: http://stackoverflow.com/a/5419576 \"\"\" tally = defaultdict(list) for i, item in enumerate(seq): tally[item].append(i) for key, locs in iteritems(tally): if len(locs) > 1: yield key, locs dstRoots = [_.dstRoot for _ in self.acquisitions] for dstRoot, dup in duplicates(dstRoots): self.logger.info(\"%s has %s runs\", dstRoot, len(dup)) self.logger.info(\"Adding 'run' information to the acquisition\") for runNum, acqInd in enumerate(dup): runStr = DEFAULT.runTpl.format(runNum + 1) self.acquisitions[acqInd].customLabels += runStr Instance variables caseSensitive searchMethod Methods build_acquisitions def build_acquisitions ( self , participant ) Parameters: Name Type Description Default participant Participant Participant object to create acquisitions None Returns: Type Description None A list of acquisition objects View Source def build_acquisitions(self, participant): \"\"\" Args: participant (Participant): Participant object to create acquisitions Returns: A list of acquisition objects \"\"\" acquisitions = [] self.logger.info(\"Sidecars pairing:\") for sidecar, descriptions in iteritems(self.graph): sidecarName = os.path.basename(sidecar.root) # only one description for the sidecar if len(descriptions) == 1: desc = descriptions[0] acq = Acquisition(participant, srcSidecar=sidecar, **desc) acquisitions.append(acq) self.logger.info(\"%s <- %s\", acq.suffix, sidecarName) # sidecar with no link elif len(descriptions) == 0: self.logger.info(\"No Pairing <- %s\", sidecarName) # sidecar with several links else: self.logger.warning(\"Several Pairing <- %s\", sidecarName) for desc in descriptions: acq = Acquisition(participant, **desc) self.logger.warning(\" -> %s\", acq.suffix) self.acquisitions = acquisitions return acquisitions build_graph def build_graph ( self ) Test all the possible links between the list of sidecars and the description dictionnaries and build a graph from it The graph is in a OrderedDict object. The keys are the Sidecars and the values are a list of possible descriptions Returns: Type Description None A graph (OrderedDict) View Source def build_graph(self): \"\"\" Test all the possible links between the list of sidecars and the description dictionnaries and build a graph from it The graph is in a OrderedDict object. The keys are the Sidecars and the values are a list of possible descriptions Returns: A graph (OrderedDict) \"\"\" graph = OrderedDict((_, []) for _ in self.sidecars) possibleLinks = itertools.product(self.sidecars, self.descriptions) for sidecar, description in possibleLinks: criteria = description.get(\"criteria\", None) if criteria and self.isLink(sidecar.data, criteria): graph[sidecar].append(description) self.graph = graph return graph find_runs def find_runs ( self ) Check if there is duplicate destination roots in the acquisitions and add '_run-' to the customLabels of the acquisition View Source def find_runs(self): \"\"\" Check if there is duplicate destination roots in the acquisitions and add '_run-' to the customLabels of the acquisition \"\"\" def duplicates(seq): \"\"\" Find duplicate items in a list Args: seq (list) Yield: A tuple of 2 items (item, list of index) ref: http://stackoverflow.com/a/5419576 \"\"\" tally = defaultdict(list) for i, item in enumerate(seq): tally[item].append(i) for key, locs in iteritems(tally): if len(locs) > 1: yield key, locs dstRoots = [_.dstRoot for _ in self.acquisitions] for dstRoot, dup in duplicates(dstRoots): self.logger.info(\"%s has %s runs\", dstRoot, len(dup)) self.logger.info(\"Adding 'run' information to the acquisition\") for runNum, acqInd in enumerate(dup): runStr = DEFAULT.runTpl.format(runNum + 1) self.acquisitions[acqInd].customLabels += runStr isLink def isLink ( self , data , criteria ) Parameters: Name Type Description Default data dict Dictionnary data of a sidecar None criteria dict Dictionnary criteria None Returns: Type Description None boolean View Source def isLink(self, data, criteria): \"\"\" Args: data (dict): Dictionnary data of a sidecar criteria (dict): Dictionnary criteria Returns: boolean \"\"\" def compare(name, pattern): if self.searchMethod == \"re\": return bool(re.search(pattern, name)) else: name = str(name) pattern = str(pattern) if not self.caseSensitive: name = name.lower() pattern = pattern.lower() return fnmatch(name, pattern) result = [] for tag, pattern in iteritems(criteria): name = data.get(tag, '')# or '' if isinstance(name, list): try: subResult = [len(name) == len(pattern), isinstance(pattern, list)] for subName, subPattern in zip(name, pattern): subResult.append(compare(subName, subPattern)) except: subResult = [False] result.append(all(subResult)) else: result.append(compare(name, pattern)) return all(result)","title":"Sidecar"},{"location":"reference/dcm2bids/sidecar/#module-dcm2bidssidecar","text":"sidecars classes None View Source # -*- coding: utf-8 -*- \"\"\"sidecars classes\"\"\" import itertools import logging import os import re from collections import defaultdict, OrderedDict from fnmatch import fnmatch from future.utils import iteritems from .structure import Acquisition from .utils import DEFAULT, load_json, splitext_ class Sidecar(object): \"\"\" A sidecar object Args: filename (str): Path of a JSON sidecar keyComp (list): A list of keys from the JSON sidecar to compare sidecars default=[\"SeriesNumber\",\"AcquisitionTime\",\"SideCarFilename\"] \"\"\" def __init__(self, filename, compKeys=DEFAULT.compKeys): self._origData = {} self._data = {} self.filename = filename self.root, _ = splitext_(filename) self.data = filename self.compKeys = compKeys def __lt__(self, other): lts = [] for key in self.compKeys: try: if all(key in d for d in (self.data, other.data)): if self.data.get(key) == other.data.get(key): lts.append(None) else: lts.append(self.data.get(key) < other.data.get(key)) else: lts.append(None) except: lts.append(None) for lt in lts: if lt is not None: return lt def __eq__(self, other): return self.data == other.data def __hash__(self): return hash(self.filename) @property def origData(self): return self._origData @property def data(self): return self._data @data.setter def data(self, filename): \"\"\" Args: filename (path): path of a JSON file Return: A dictionnary of the JSON content plus the SidecarFilename \"\"\" try: data = load_json(filename) except: data = {} self._origData = data.copy() data[\"SidecarFilename\"] = os.path.basename(filename) self._data = data class SidecarPairing(object): \"\"\" Args: sidecars (list): List of Sidecar objects descriptions (list): List of dictionnaries describing acquisitions \"\"\" def __init__(self, sidecars, descriptions, searchMethod=DEFAULT.searchMethod, caseSensitive=DEFAULT.caseSensitive): self.logger = logging.getLogger(__name__) self._searchMethod = \"\" self.graph = OrderedDict() self.aquisitions = [] self.sidecars = sidecars self.descriptions = descriptions self.searchMethod = searchMethod self.caseSensitive = caseSensitive @property def searchMethod(self): return self._searchMethod @searchMethod.setter def searchMethod(self, value): \"\"\" Checks if the search method is implemented Warns the user if not and fall back to default \"\"\" if value in DEFAULT.searchMethodChoices: self._searchMethod = value else: self._searchMethod = DEFAULT.searchMethod self.logger.warning(\"'%s' is not a search method implemented\", value) self.logger.warning( \"Falling back to default: %s\", DEFAULT.searchMethod ) self.logger.warning( \"Search methods implemented: %s\", DEFAULT.searchMethodChoices ) @property def caseSensitive(self): return self._caseSensitive @caseSensitive.setter def caseSensitive(self, value): if isinstance(value, bool): self._caseSensitive = value else: self._caseSensitive = DEFAULT.caseSensitive self.logger.warning(\"'%s' is not a boolean\", value) self.logger.warning( \"Falling back to default: %s\", DEFAULT.caseSensitive ) self.logger.warning( \"Search methods implemented: %s\", DEFAULT.caseSensitive ) def build_graph(self): \"\"\" Test all the possible links between the list of sidecars and the description dictionnaries and build a graph from it The graph is in a OrderedDict object. The keys are the Sidecars and the values are a list of possible descriptions Returns: A graph (OrderedDict) \"\"\" graph = OrderedDict((_, []) for _ in self.sidecars) possibleLinks = itertools.product(self.sidecars, self.descriptions) for sidecar, description in possibleLinks: criteria = description.get(\"criteria\", None) if criteria and self.isLink(sidecar.data, criteria): graph[sidecar].append(description) self.graph = graph return graph def isLink(self, data, criteria): \"\"\" Args: data (dict): Dictionnary data of a sidecar criteria (dict): Dictionnary criteria Returns: boolean \"\"\" def compare(name, pattern): if self.searchMethod == \"re\": return bool(re.search(pattern, name)) else: name = str(name) pattern = str(pattern) if not self.caseSensitive: name = name.lower() pattern = pattern.lower() return fnmatch(name, pattern) result = [] for tag, pattern in iteritems(criteria): name = data.get(tag, '')# or '' if isinstance(name, list): try: subResult = [len(name) == len(pattern), isinstance(pattern, list)] for subName, subPattern in zip(name, pattern): subResult.append(compare(subName, subPattern)) except: subResult = [False] result.append(all(subResult)) else: result.append(compare(name, pattern)) return all(result) def build_acquisitions(self, participant): \"\"\" Args: participant (Participant): Participant object to create acquisitions Returns: A list of acquisition objects \"\"\" acquisitions = [] self.logger.info(\"Sidecars pairing:\") for sidecar, descriptions in iteritems(self.graph): sidecarName = os.path.basename(sidecar.root) # only one description for the sidecar if len(descriptions) == 1: desc = descriptions[0] acq = Acquisition(participant, srcSidecar=sidecar, **desc) acquisitions.append(acq) self.logger.info(\"%s <- %s\", acq.suffix, sidecarName) # sidecar with no link elif len(descriptions) == 0: self.logger.info(\"No Pairing <- %s\", sidecarName) # sidecar with several links else: self.logger.warning(\"Several Pairing <- %s\", sidecarName) for desc in descriptions: acq = Acquisition(participant, **desc) self.logger.warning(\" -> %s\", acq.suffix) self.acquisitions = acquisitions return acquisitions def find_runs(self): \"\"\" Check if there is duplicate destination roots in the acquisitions and add '_run-' to the customLabels of the acquisition \"\"\" def duplicates(seq): \"\"\" Find duplicate items in a list Args: seq (list) Yield: A tuple of 2 items (item, list of index) ref: http://stackoverflow.com/a/5419576 \"\"\" tally = defaultdict(list) for i, item in enumerate(seq): tally[item].append(i) for key, locs in iteritems(tally): if len(locs) > 1: yield key, locs dstRoots = [_.dstRoot for _ in self.acquisitions] for dstRoot, dup in duplicates(dstRoots): self.logger.info(\"%s has %s runs\", dstRoot, len(dup)) self.logger.info(\"Adding 'run' information to the acquisition\") for runNum, acqInd in enumerate(dup): runStr = DEFAULT.runTpl.format(runNum + 1) self.acquisitions[acqInd].customLabels += runStr","title":"Module dcm2bids.sidecar"},{"location":"reference/dcm2bids/sidecar/#classes","text":"","title":"Classes"},{"location":"reference/dcm2bids/sidecar/#sidecar","text":"class Sidecar ( filename , compKeys = [ 'SeriesNumber' , 'AcquisitionTime' , 'SidecarFilename' ] )","title":"Sidecar"},{"location":"reference/dcm2bids/sidecar/#attributes","text":"Name Type Description Default filename str Path of a JSON sidecar None keyComp list A list of keys from the JSON sidecar to compare sidecars default=[\"SeriesNumber\",\"AcquisitionTime\",\"SideCarFilename\"] None View Source class Sidecar(object): \"\"\" A sidecar object Args: filename (str): Path of a JSON sidecar keyComp (list): A list of keys from the JSON sidecar to compare sidecars default=[\"SeriesNumber\",\"AcquisitionTime\",\"SideCarFilename\"] \"\"\" def __init__(self, filename, compKeys=DEFAULT.compKeys): self._origData = {} self._data = {} self.filename = filename self.root, _ = splitext_(filename) self.data = filename self.compKeys = compKeys def __lt__(self, other): lts = [] for key in self.compKeys: try: if all(key in d for d in (self.data, other.data)): if self.data.get(key) == other.data.get(key): lts.append(None) else: lts.append(self.data.get(key) < other.data.get(key)) else: lts.append(None) except: lts.append(None) for lt in lts: if lt is not None: return lt def __eq__(self, other): return self.data == other.data def __hash__(self): return hash(self.filename) @property def origData(self): return self._origData @property def data(self): return self._data @data.setter def data(self, filename): \"\"\" Args: filename (path): path of a JSON file Return: A dictionnary of the JSON content plus the SidecarFilename \"\"\" try: data = load_json(filename) except: data = {} self._origData = data.copy() data[\"SidecarFilename\"] = os.path.basename(filename) self._data = data","title":"Attributes"},{"location":"reference/dcm2bids/sidecar/#instance-variables","text":"data origData","title":"Instance variables"},{"location":"reference/dcm2bids/sidecar/#sidecarpairing","text":"class SidecarPairing ( sidecars , descriptions , searchMethod = 'fnmatch' , caseSensitive = True ) View Source class SidecarPairing(object): \"\"\" Args: sidecars (list): List of Sidecar objects descriptions (list): List of dictionnaries describing acquisitions \"\"\" def __init__(self, sidecars, descriptions, searchMethod=DEFAULT.searchMethod, caseSensitive=DEFAULT.caseSensitive): self.logger = logging.getLogger(__name__) self._searchMethod = \"\" self.graph = OrderedDict() self.aquisitions = [] self.sidecars = sidecars self.descriptions = descriptions self.searchMethod = searchMethod self.caseSensitive = caseSensitive @property def searchMethod(self): return self._searchMethod @searchMethod.setter def searchMethod(self, value): \"\"\" Checks if the search method is implemented Warns the user if not and fall back to default \"\"\" if value in DEFAULT.searchMethodChoices: self._searchMethod = value else: self._searchMethod = DEFAULT.searchMethod self.logger.warning(\"'%s' is not a search method implemented\", value) self.logger.warning( \"Falling back to default: %s\", DEFAULT.searchMethod ) self.logger.warning( \"Search methods implemented: %s\", DEFAULT.searchMethodChoices ) @property def caseSensitive(self): return self._caseSensitive @caseSensitive.setter def caseSensitive(self, value): if isinstance(value, bool): self._caseSensitive = value else: self._caseSensitive = DEFAULT.caseSensitive self.logger.warning(\"'%s' is not a boolean\", value) self.logger.warning( \"Falling back to default: %s\", DEFAULT.caseSensitive ) self.logger.warning( \"Search methods implemented: %s\", DEFAULT.caseSensitive ) def build_graph(self): \"\"\" Test all the possible links between the list of sidecars and the description dictionnaries and build a graph from it The graph is in a OrderedDict object. The keys are the Sidecars and the values are a list of possible descriptions Returns: A graph (OrderedDict) \"\"\" graph = OrderedDict((_, []) for _ in self.sidecars) possibleLinks = itertools.product(self.sidecars, self.descriptions) for sidecar, description in possibleLinks: criteria = description.get(\"criteria\", None) if criteria and self.isLink(sidecar.data, criteria): graph[sidecar].append(description) self.graph = graph return graph def isLink(self, data, criteria): \"\"\" Args: data (dict): Dictionnary data of a sidecar criteria (dict): Dictionnary criteria Returns: boolean \"\"\" def compare(name, pattern): if self.searchMethod == \"re\": return bool(re.search(pattern, name)) else: name = str(name) pattern = str(pattern) if not self.caseSensitive: name = name.lower() pattern = pattern.lower() return fnmatch(name, pattern) result = [] for tag, pattern in iteritems(criteria): name = data.get(tag, '')# or '' if isinstance(name, list): try: subResult = [len(name) == len(pattern), isinstance(pattern, list)] for subName, subPattern in zip(name, pattern): subResult.append(compare(subName, subPattern)) except: subResult = [False] result.append(all(subResult)) else: result.append(compare(name, pattern)) return all(result) def build_acquisitions(self, participant): \"\"\" Args: participant (Participant): Participant object to create acquisitions Returns: A list of acquisition objects \"\"\" acquisitions = [] self.logger.info(\"Sidecars pairing:\") for sidecar, descriptions in iteritems(self.graph): sidecarName = os.path.basename(sidecar.root) # only one description for the sidecar if len(descriptions) == 1: desc = descriptions[0] acq = Acquisition(participant, srcSidecar=sidecar, **desc) acquisitions.append(acq) self.logger.info(\"%s <- %s\", acq.suffix, sidecarName) # sidecar with no link elif len(descriptions) == 0: self.logger.info(\"No Pairing <- %s\", sidecarName) # sidecar with several links else: self.logger.warning(\"Several Pairing <- %s\", sidecarName) for desc in descriptions: acq = Acquisition(participant, **desc) self.logger.warning(\" -> %s\", acq.suffix) self.acquisitions = acquisitions return acquisitions def find_runs(self): \"\"\" Check if there is duplicate destination roots in the acquisitions and add '_run-' to the customLabels of the acquisition \"\"\" def duplicates(seq): \"\"\" Find duplicate items in a list Args: seq (list) Yield: A tuple of 2 items (item, list of index) ref: http://stackoverflow.com/a/5419576 \"\"\" tally = defaultdict(list) for i, item in enumerate(seq): tally[item].append(i) for key, locs in iteritems(tally): if len(locs) > 1: yield key, locs dstRoots = [_.dstRoot for _ in self.acquisitions] for dstRoot, dup in duplicates(dstRoots): self.logger.info(\"%s has %s runs\", dstRoot, len(dup)) self.logger.info(\"Adding 'run' information to the acquisition\") for runNum, acqInd in enumerate(dup): runStr = DEFAULT.runTpl.format(runNum + 1) self.acquisitions[acqInd].customLabels += runStr","title":"SidecarPairing"},{"location":"reference/dcm2bids/sidecar/#instance-variables_1","text":"caseSensitive searchMethod","title":"Instance variables"},{"location":"reference/dcm2bids/sidecar/#methods","text":"","title":"Methods"},{"location":"reference/dcm2bids/sidecar/#build_acquisitions","text":"def build_acquisitions ( self , participant ) Parameters: Name Type Description Default participant Participant Participant object to create acquisitions None Returns: Type Description None A list of acquisition objects View Source def build_acquisitions(self, participant): \"\"\" Args: participant (Participant): Participant object to create acquisitions Returns: A list of acquisition objects \"\"\" acquisitions = [] self.logger.info(\"Sidecars pairing:\") for sidecar, descriptions in iteritems(self.graph): sidecarName = os.path.basename(sidecar.root) # only one description for the sidecar if len(descriptions) == 1: desc = descriptions[0] acq = Acquisition(participant, srcSidecar=sidecar, **desc) acquisitions.append(acq) self.logger.info(\"%s <- %s\", acq.suffix, sidecarName) # sidecar with no link elif len(descriptions) == 0: self.logger.info(\"No Pairing <- %s\", sidecarName) # sidecar with several links else: self.logger.warning(\"Several Pairing <- %s\", sidecarName) for desc in descriptions: acq = Acquisition(participant, **desc) self.logger.warning(\" -> %s\", acq.suffix) self.acquisitions = acquisitions return acquisitions","title":"build_acquisitions"},{"location":"reference/dcm2bids/sidecar/#build_graph","text":"def build_graph ( self ) Test all the possible links between the list of sidecars and the description dictionnaries and build a graph from it The graph is in a OrderedDict object. The keys are the Sidecars and the values are a list of possible descriptions Returns: Type Description None A graph (OrderedDict) View Source def build_graph(self): \"\"\" Test all the possible links between the list of sidecars and the description dictionnaries and build a graph from it The graph is in a OrderedDict object. The keys are the Sidecars and the values are a list of possible descriptions Returns: A graph (OrderedDict) \"\"\" graph = OrderedDict((_, []) for _ in self.sidecars) possibleLinks = itertools.product(self.sidecars, self.descriptions) for sidecar, description in possibleLinks: criteria = description.get(\"criteria\", None) if criteria and self.isLink(sidecar.data, criteria): graph[sidecar].append(description) self.graph = graph return graph","title":"build_graph"},{"location":"reference/dcm2bids/sidecar/#find_runs","text":"def find_runs ( self ) Check if there is duplicate destination roots in the acquisitions and add '_run-' to the customLabels of the acquisition View Source def find_runs(self): \"\"\" Check if there is duplicate destination roots in the acquisitions and add '_run-' to the customLabels of the acquisition \"\"\" def duplicates(seq): \"\"\" Find duplicate items in a list Args: seq (list) Yield: A tuple of 2 items (item, list of index) ref: http://stackoverflow.com/a/5419576 \"\"\" tally = defaultdict(list) for i, item in enumerate(seq): tally[item].append(i) for key, locs in iteritems(tally): if len(locs) > 1: yield key, locs dstRoots = [_.dstRoot for _ in self.acquisitions] for dstRoot, dup in duplicates(dstRoots): self.logger.info(\"%s has %s runs\", dstRoot, len(dup)) self.logger.info(\"Adding 'run' information to the acquisition\") for runNum, acqInd in enumerate(dup): runStr = DEFAULT.runTpl.format(runNum + 1) self.acquisitions[acqInd].customLabels += runStr","title":"find_runs"},{"location":"reference/dcm2bids/sidecar/#islink","text":"def isLink ( self , data , criteria ) Parameters: Name Type Description Default data dict Dictionnary data of a sidecar None criteria dict Dictionnary criteria None Returns: Type Description None boolean View Source def isLink(self, data, criteria): \"\"\" Args: data (dict): Dictionnary data of a sidecar criteria (dict): Dictionnary criteria Returns: boolean \"\"\" def compare(name, pattern): if self.searchMethod == \"re\": return bool(re.search(pattern, name)) else: name = str(name) pattern = str(pattern) if not self.caseSensitive: name = name.lower() pattern = pattern.lower() return fnmatch(name, pattern) result = [] for tag, pattern in iteritems(criteria): name = data.get(tag, '')# or '' if isinstance(name, list): try: subResult = [len(name) == len(pattern), isinstance(pattern, list)] for subName, subPattern in zip(name, pattern): subResult.append(compare(subName, subPattern)) except: subResult = [False] result.append(all(subResult)) else: result.append(compare(name, pattern)) return all(result)","title":"isLink"},{"location":"reference/dcm2bids/structure/","text":"Module dcm2bids.structure k None View Source # -*- coding: utf-8 -*- \"\"\"k\"\"\" from os.path import join as opj from future.utils import iteritems from .utils import DEFAULT from .version import __version__ class Participant(object): \"\"\" Class representing a participant Args: name (str): Label of your participant session (str): Optional label of a session \"\"\" def __init__(self, name, session=DEFAULT.session): self._name = \"\" self._session = \"\" self.name = name self.session = session @property def name(self): \"\"\" Returns: A string 'sub-<subject_label>' \"\"\" return self._name @name.setter def name(self, name): \"\"\" Prepend 'sub-' if necessary\"\"\" if name.startswith(\"sub-\"): self._name = name else: self._name = \"sub-\" + name @property def session(self): \"\"\" Returns: A string 'ses-<session_label>' \"\"\" return self._session @session.setter def session(self, session): \"\"\" Prepend 'ses-' if necessary\"\"\" if session.strip() == \"\": self._session = \"\" elif session.startswith(\"ses-\"): self._session = session else: self._session = \"ses-\" + session @property def directory(self): \"\"\" The directory of the participant Returns: A path 'sub-<subject_label>' or 'sub-<subject_label>/ses-<session_label>' \"\"\" if self.hasSession(): return opj(self.name, self.session) else: return self.name @property def prefix(self): \"\"\" The prefix to build filenames Returns: A string 'sub-<subject_label>' or 'sub-<subject_label>_ses-<session_label>' \"\"\" if self.hasSession(): return self.name + \"_\" + self.session else: return self.name def hasSession(self): \"\"\" Check if a session is set Returns: Boolean \"\"\" return self.session.strip() != DEFAULT.session class Acquisition(object): \"\"\" Class representing an acquisition Args: participant (Participant): A participant object dataType (str): A functional group of MRI data (ex: func, anat ...) modalityLabel (str): The modality of the acquisition (ex: T1w, T2w, bold ...) customLabels (str): Optional labels (ex: task-rest) srcSidecar (Sidecar): Optional sidecar object \"\"\" def __init__( self, participant, dataType, modalityLabel, customLabels=\"\", srcSidecar=None, sidecarChanges=None, intendedFor=None, IntendedFor=None, **kwargs ): self._modalityLabel = \"\" self._customLabels = \"\" self._intendedFor = None self.participant = participant self.dataType = dataType self.modalityLabel = modalityLabel self.customLabels = customLabels self.srcSidecar = srcSidecar if sidecarChanges is None: self.sidecarChanges = {} else: self.sidecarChanges = sidecarChanges if intendedFor is None: self.intendedFor = IntendedFor else: self.intendedFor = intendedFor def __eq__(self, other): return ( self.dataType == other.dataType and self.participant.prefix == other.participant.prefix and self.suffix == other.suffix ) @property def modalityLabel(self): \"\"\" Returns: A string '_<modalityLabel>' \"\"\" return self._modalityLabel @modalityLabel.setter def modalityLabel(self, modalityLabel): \"\"\" Prepend '_' if necessary\"\"\" self._modalityLabel = self.prepend(modalityLabel) @property def customLabels(self): \"\"\" Returns: A string '_<customLabels>' \"\"\" return self._customLabels @customLabels.setter def customLabels(self, customLabels): \"\"\" Prepend '_' if necessary\"\"\" self._customLabels = self.prepend(customLabels) @property def suffix(self): \"\"\" The suffix to build filenames Returns: A string '_<modalityLabel>' or '_<customLabels>_<modalityLabel>' \"\"\" if self.customLabels.strip() == \"\": return self.modalityLabel else: return self.customLabels + self.modalityLabel @property def srcRoot(self): \"\"\" Return: The sidecar source root to move \"\"\" if self.srcSidecar: return self.srcSidecar.root else: return None @property def dstRoot(self): \"\"\" Return: The destination root inside the BIDS structure \"\"\" return opj( self.participant.directory, self.dataType, self.participant.prefix + self.suffix, ) @property def intendedFor(self): return self._intendedFor @intendedFor.setter def intendedFor(self, value): if isinstance(value, list): self._intendedFor = value else: self._intendedFor = [value] def dstSidecarData(self, descriptions): \"\"\" \"\"\" data = self.srcSidecar.origData data[\"Dcm2bidsVersion\"] = __version__ # intendedFor key if self.intendedFor != [None]: intendedValue = [] for index in self.intendedFor: intendedDesc = descriptions[index] session = self.participant.session dataType = intendedDesc[\"dataType\"] niiFile = self.participant.prefix niiFile += self.prepend(intendedDesc.get(\"customLabels\", \"\")) niiFile += self.prepend(intendedDesc[\"modalityLabel\"]) niiFile += \".nii.gz\" intendedValue.append(opj(session, dataType, niiFile).replace(\"\\\\\", \"/\")) if len(intendedValue) == 1: data[\"IntendedFor\"] = intendedValue[0] else: data[\"IntendedFor\"] = intendedValue # sidecarChanges for key, value in iteritems(self.sidecarChanges): data[key] = value return data @staticmethod def prepend(value, char=\"_\"): \"\"\" Prepend `char` to `value` if necessary Args: value (str) char (str) \"\"\" if value.strip() == \"\": return \"\" elif value.startswith(char): return value else: return char + value Classes Acquisition class Acquisition ( participant , dataType , modalityLabel , customLabels = '' , srcSidecar = None , sidecarChanges = None , intendedFor = None , IntendedFor = None , ** kwargs ) Attributes Name Type Description Default participant Participant A participant object None dataType str A functional group of MRI data (ex: func, anat ...) None modalityLabel str The modality of the acquisition (ex: T1w, T2w, bold ...) None customLabels str Optional labels (ex: task-rest) None srcSidecar Sidecar Optional sidecar object None View Source class Acquisition(object): \"\"\" Class representing an acquisition Args: participant (Participant): A participant object dataType (str): A functional group of MRI data (ex: func, anat ...) modalityLabel (str): The modality of the acquisition (ex: T1w, T2w, bold ...) customLabels (str): Optional labels (ex: task-rest) srcSidecar (Sidecar): Optional sidecar object \"\"\" def __init__( self, participant, dataType, modalityLabel, customLabels=\"\", srcSidecar=None, sidecarChanges=None, intendedFor=None, IntendedFor=None, **kwargs ): self._modalityLabel = \"\" self._customLabels = \"\" self._intendedFor = None self.participant = participant self.dataType = dataType self.modalityLabel = modalityLabel self.customLabels = customLabels self.srcSidecar = srcSidecar if sidecarChanges is None: self.sidecarChanges = {} else: self.sidecarChanges = sidecarChanges if intendedFor is None: self.intendedFor = IntendedFor else: self.intendedFor = intendedFor def __eq__(self, other): return ( self.dataType == other.dataType and self.participant.prefix == other.participant.prefix and self.suffix == other.suffix ) @property def modalityLabel(self): \"\"\" Returns: A string '_<modalityLabel>' \"\"\" return self._modalityLabel @modalityLabel.setter def modalityLabel(self, modalityLabel): \"\"\" Prepend '_' if necessary\"\"\" self._modalityLabel = self.prepend(modalityLabel) @property def customLabels(self): \"\"\" Returns: A string '_<customLabels>' \"\"\" return self._customLabels @customLabels.setter def customLabels(self, customLabels): \"\"\" Prepend '_' if necessary\"\"\" self._customLabels = self.prepend(customLabels) @property def suffix(self): \"\"\" The suffix to build filenames Returns: A string '_<modalityLabel>' or '_<customLabels>_<modalityLabel>' \"\"\" if self.customLabels.strip() == \"\": return self.modalityLabel else: return self.customLabels + self.modalityLabel @property def srcRoot(self): \"\"\" Return: The sidecar source root to move \"\"\" if self.srcSidecar: return self.srcSidecar.root else: return None @property def dstRoot(self): \"\"\" Return: The destination root inside the BIDS structure \"\"\" return opj( self.participant.directory, self.dataType, self.participant.prefix + self.suffix, ) @property def intendedFor(self): return self._intendedFor @intendedFor.setter def intendedFor(self, value): if isinstance(value, list): self._intendedFor = value else: self._intendedFor = [value] def dstSidecarData(self, descriptions): \"\"\" \"\"\" data = self.srcSidecar.origData data[\"Dcm2bidsVersion\"] = __version__ # intendedFor key if self.intendedFor != [None]: intendedValue = [] for index in self.intendedFor: intendedDesc = descriptions[index] session = self.participant.session dataType = intendedDesc[\"dataType\"] niiFile = self.participant.prefix niiFile += self.prepend(intendedDesc.get(\"customLabels\", \"\")) niiFile += self.prepend(intendedDesc[\"modalityLabel\"]) niiFile += \".nii.gz\" intendedValue.append(opj(session, dataType, niiFile).replace(\"\\\\\", \"/\")) if len(intendedValue) == 1: data[\"IntendedFor\"] = intendedValue[0] else: data[\"IntendedFor\"] = intendedValue # sidecarChanges for key, value in iteritems(self.sidecarChanges): data[key] = value return data @staticmethod def prepend(value, char=\"_\"): \"\"\" Prepend `char` to `value` if necessary Args: value (str) char (str) \"\"\" if value.strip() == \"\": return \"\" elif value.startswith(char): return value else: return char + value Static methods prepend def prepend ( value , char = '_' ) Prepend char to value if necessary Args: value (str) char (str) View Source @staticmethod def prepend(value, char=\"_\"): \"\"\" Prepend `char` to `value` if necessary Args: value (str) char (str) \"\"\" if value.strip() == \"\": return \"\" elif value.startswith(char): return value else: return char + value Instance variables customLabels Returns: A string '_ ' dstRoot Return: The destination root inside the BIDS structure intendedFor modalityLabel Returns: A string '_ ' srcRoot Return: The sidecar source root to move suffix The suffix to build filenames Methods dstSidecarData def dstSidecarData ( self , descriptions ) View Source def dstSidecarData(self, descriptions): \"\"\" \"\"\" data = self.srcSidecar.origData data[\"Dcm2bidsVersion\"] = __version__ # intendedFor key if self.intendedFor != [None]: intendedValue = [] for index in self.intendedFor: intendedDesc = descriptions[index] session = self.participant.session dataType = intendedDesc[\"dataType\"] niiFile = self.participant.prefix niiFile += self.prepend(intendedDesc.get(\"customLabels\", \"\")) niiFile += self.prepend(intendedDesc[\"modalityLabel\"]) niiFile += \".nii.gz\" intendedValue.append(opj(session, dataType, niiFile).replace(\"\\\\\", \"/\")) if len(intendedValue) == 1: data[\"IntendedFor\"] = intendedValue[0] else: data[\"IntendedFor\"] = intendedValue # sidecarChanges for key, value in iteritems(self.sidecarChanges): data[key] = value return data Participant class Participant ( name , session = '' ) Attributes Name Type Description Default name str Label of your participant None session str Optional label of a session None View Source class Participant(object): \"\"\" Class representing a participant Args: name (str): Label of your participant session (str): Optional label of a session \"\"\" def __init__(self, name, session=DEFAULT.session): self._name = \"\" self._session = \"\" self.name = name self.session = session @property def name(self): \"\"\" Returns: A string 'sub-<subject_label>' \"\"\" return self._name @name.setter def name(self, name): \"\"\" Prepend 'sub-' if necessary\"\"\" if name.startswith(\"sub-\"): self._name = name else: self._name = \"sub-\" + name @property def session(self): \"\"\" Returns: A string 'ses-<session_label>' \"\"\" return self._session @session.setter def session(self, session): \"\"\" Prepend 'ses-' if necessary\"\"\" if session.strip() == \"\": self._session = \"\" elif session.startswith(\"ses-\"): self._session = session else: self._session = \"ses-\" + session @property def directory(self): \"\"\" The directory of the participant Returns: A path 'sub-<subject_label>' or 'sub-<subject_label>/ses-<session_label>' \"\"\" if self.hasSession(): return opj(self.name, self.session) else: return self.name @property def prefix(self): \"\"\" The prefix to build filenames Returns: A string 'sub-<subject_label>' or 'sub-<subject_label>_ses-<session_label>' \"\"\" if self.hasSession(): return self.name + \"_\" + self.session else: return self.name def hasSession(self): \"\"\" Check if a session is set Returns: Boolean \"\"\" return self.session.strip() != DEFAULT.session Instance variables directory The directory of the participant name Returns: A string 'sub- ' prefix The prefix to build filenames session Returns: A string 'ses- ' Methods hasSession def hasSession ( self ) Check if a session is set Returns: Type Description None Boolean View Source def hasSession(self): \"\"\" Check if a session is set Returns: Boolean \"\"\" return self.session.strip() != DEFAULT.session","title":"Structure"},{"location":"reference/dcm2bids/structure/#module-dcm2bidsstructure","text":"k None View Source # -*- coding: utf-8 -*- \"\"\"k\"\"\" from os.path import join as opj from future.utils import iteritems from .utils import DEFAULT from .version import __version__ class Participant(object): \"\"\" Class representing a participant Args: name (str): Label of your participant session (str): Optional label of a session \"\"\" def __init__(self, name, session=DEFAULT.session): self._name = \"\" self._session = \"\" self.name = name self.session = session @property def name(self): \"\"\" Returns: A string 'sub-<subject_label>' \"\"\" return self._name @name.setter def name(self, name): \"\"\" Prepend 'sub-' if necessary\"\"\" if name.startswith(\"sub-\"): self._name = name else: self._name = \"sub-\" + name @property def session(self): \"\"\" Returns: A string 'ses-<session_label>' \"\"\" return self._session @session.setter def session(self, session): \"\"\" Prepend 'ses-' if necessary\"\"\" if session.strip() == \"\": self._session = \"\" elif session.startswith(\"ses-\"): self._session = session else: self._session = \"ses-\" + session @property def directory(self): \"\"\" The directory of the participant Returns: A path 'sub-<subject_label>' or 'sub-<subject_label>/ses-<session_label>' \"\"\" if self.hasSession(): return opj(self.name, self.session) else: return self.name @property def prefix(self): \"\"\" The prefix to build filenames Returns: A string 'sub-<subject_label>' or 'sub-<subject_label>_ses-<session_label>' \"\"\" if self.hasSession(): return self.name + \"_\" + self.session else: return self.name def hasSession(self): \"\"\" Check if a session is set Returns: Boolean \"\"\" return self.session.strip() != DEFAULT.session class Acquisition(object): \"\"\" Class representing an acquisition Args: participant (Participant): A participant object dataType (str): A functional group of MRI data (ex: func, anat ...) modalityLabel (str): The modality of the acquisition (ex: T1w, T2w, bold ...) customLabels (str): Optional labels (ex: task-rest) srcSidecar (Sidecar): Optional sidecar object \"\"\" def __init__( self, participant, dataType, modalityLabel, customLabels=\"\", srcSidecar=None, sidecarChanges=None, intendedFor=None, IntendedFor=None, **kwargs ): self._modalityLabel = \"\" self._customLabels = \"\" self._intendedFor = None self.participant = participant self.dataType = dataType self.modalityLabel = modalityLabel self.customLabels = customLabels self.srcSidecar = srcSidecar if sidecarChanges is None: self.sidecarChanges = {} else: self.sidecarChanges = sidecarChanges if intendedFor is None: self.intendedFor = IntendedFor else: self.intendedFor = intendedFor def __eq__(self, other): return ( self.dataType == other.dataType and self.participant.prefix == other.participant.prefix and self.suffix == other.suffix ) @property def modalityLabel(self): \"\"\" Returns: A string '_<modalityLabel>' \"\"\" return self._modalityLabel @modalityLabel.setter def modalityLabel(self, modalityLabel): \"\"\" Prepend '_' if necessary\"\"\" self._modalityLabel = self.prepend(modalityLabel) @property def customLabels(self): \"\"\" Returns: A string '_<customLabels>' \"\"\" return self._customLabels @customLabels.setter def customLabels(self, customLabels): \"\"\" Prepend '_' if necessary\"\"\" self._customLabels = self.prepend(customLabels) @property def suffix(self): \"\"\" The suffix to build filenames Returns: A string '_<modalityLabel>' or '_<customLabels>_<modalityLabel>' \"\"\" if self.customLabels.strip() == \"\": return self.modalityLabel else: return self.customLabels + self.modalityLabel @property def srcRoot(self): \"\"\" Return: The sidecar source root to move \"\"\" if self.srcSidecar: return self.srcSidecar.root else: return None @property def dstRoot(self): \"\"\" Return: The destination root inside the BIDS structure \"\"\" return opj( self.participant.directory, self.dataType, self.participant.prefix + self.suffix, ) @property def intendedFor(self): return self._intendedFor @intendedFor.setter def intendedFor(self, value): if isinstance(value, list): self._intendedFor = value else: self._intendedFor = [value] def dstSidecarData(self, descriptions): \"\"\" \"\"\" data = self.srcSidecar.origData data[\"Dcm2bidsVersion\"] = __version__ # intendedFor key if self.intendedFor != [None]: intendedValue = [] for index in self.intendedFor: intendedDesc = descriptions[index] session = self.participant.session dataType = intendedDesc[\"dataType\"] niiFile = self.participant.prefix niiFile += self.prepend(intendedDesc.get(\"customLabels\", \"\")) niiFile += self.prepend(intendedDesc[\"modalityLabel\"]) niiFile += \".nii.gz\" intendedValue.append(opj(session, dataType, niiFile).replace(\"\\\\\", \"/\")) if len(intendedValue) == 1: data[\"IntendedFor\"] = intendedValue[0] else: data[\"IntendedFor\"] = intendedValue # sidecarChanges for key, value in iteritems(self.sidecarChanges): data[key] = value return data @staticmethod def prepend(value, char=\"_\"): \"\"\" Prepend `char` to `value` if necessary Args: value (str) char (str) \"\"\" if value.strip() == \"\": return \"\" elif value.startswith(char): return value else: return char + value","title":"Module dcm2bids.structure"},{"location":"reference/dcm2bids/structure/#classes","text":"","title":"Classes"},{"location":"reference/dcm2bids/structure/#acquisition","text":"class Acquisition ( participant , dataType , modalityLabel , customLabels = '' , srcSidecar = None , sidecarChanges = None , intendedFor = None , IntendedFor = None , ** kwargs )","title":"Acquisition"},{"location":"reference/dcm2bids/structure/#attributes","text":"Name Type Description Default participant Participant A participant object None dataType str A functional group of MRI data (ex: func, anat ...) None modalityLabel str The modality of the acquisition (ex: T1w, T2w, bold ...) None customLabels str Optional labels (ex: task-rest) None srcSidecar Sidecar Optional sidecar object None View Source class Acquisition(object): \"\"\" Class representing an acquisition Args: participant (Participant): A participant object dataType (str): A functional group of MRI data (ex: func, anat ...) modalityLabel (str): The modality of the acquisition (ex: T1w, T2w, bold ...) customLabels (str): Optional labels (ex: task-rest) srcSidecar (Sidecar): Optional sidecar object \"\"\" def __init__( self, participant, dataType, modalityLabel, customLabels=\"\", srcSidecar=None, sidecarChanges=None, intendedFor=None, IntendedFor=None, **kwargs ): self._modalityLabel = \"\" self._customLabels = \"\" self._intendedFor = None self.participant = participant self.dataType = dataType self.modalityLabel = modalityLabel self.customLabels = customLabels self.srcSidecar = srcSidecar if sidecarChanges is None: self.sidecarChanges = {} else: self.sidecarChanges = sidecarChanges if intendedFor is None: self.intendedFor = IntendedFor else: self.intendedFor = intendedFor def __eq__(self, other): return ( self.dataType == other.dataType and self.participant.prefix == other.participant.prefix and self.suffix == other.suffix ) @property def modalityLabel(self): \"\"\" Returns: A string '_<modalityLabel>' \"\"\" return self._modalityLabel @modalityLabel.setter def modalityLabel(self, modalityLabel): \"\"\" Prepend '_' if necessary\"\"\" self._modalityLabel = self.prepend(modalityLabel) @property def customLabels(self): \"\"\" Returns: A string '_<customLabels>' \"\"\" return self._customLabels @customLabels.setter def customLabels(self, customLabels): \"\"\" Prepend '_' if necessary\"\"\" self._customLabels = self.prepend(customLabels) @property def suffix(self): \"\"\" The suffix to build filenames Returns: A string '_<modalityLabel>' or '_<customLabels>_<modalityLabel>' \"\"\" if self.customLabels.strip() == \"\": return self.modalityLabel else: return self.customLabels + self.modalityLabel @property def srcRoot(self): \"\"\" Return: The sidecar source root to move \"\"\" if self.srcSidecar: return self.srcSidecar.root else: return None @property def dstRoot(self): \"\"\" Return: The destination root inside the BIDS structure \"\"\" return opj( self.participant.directory, self.dataType, self.participant.prefix + self.suffix, ) @property def intendedFor(self): return self._intendedFor @intendedFor.setter def intendedFor(self, value): if isinstance(value, list): self._intendedFor = value else: self._intendedFor = [value] def dstSidecarData(self, descriptions): \"\"\" \"\"\" data = self.srcSidecar.origData data[\"Dcm2bidsVersion\"] = __version__ # intendedFor key if self.intendedFor != [None]: intendedValue = [] for index in self.intendedFor: intendedDesc = descriptions[index] session = self.participant.session dataType = intendedDesc[\"dataType\"] niiFile = self.participant.prefix niiFile += self.prepend(intendedDesc.get(\"customLabels\", \"\")) niiFile += self.prepend(intendedDesc[\"modalityLabel\"]) niiFile += \".nii.gz\" intendedValue.append(opj(session, dataType, niiFile).replace(\"\\\\\", \"/\")) if len(intendedValue) == 1: data[\"IntendedFor\"] = intendedValue[0] else: data[\"IntendedFor\"] = intendedValue # sidecarChanges for key, value in iteritems(self.sidecarChanges): data[key] = value return data @staticmethod def prepend(value, char=\"_\"): \"\"\" Prepend `char` to `value` if necessary Args: value (str) char (str) \"\"\" if value.strip() == \"\": return \"\" elif value.startswith(char): return value else: return char + value","title":"Attributes"},{"location":"reference/dcm2bids/structure/#static-methods","text":"","title":"Static methods"},{"location":"reference/dcm2bids/structure/#prepend","text":"def prepend ( value , char = '_' ) Prepend char to value if necessary Args: value (str) char (str) View Source @staticmethod def prepend(value, char=\"_\"): \"\"\" Prepend `char` to `value` if necessary Args: value (str) char (str) \"\"\" if value.strip() == \"\": return \"\" elif value.startswith(char): return value else: return char + value","title":"prepend"},{"location":"reference/dcm2bids/structure/#instance-variables","text":"customLabels Returns: A string '_ ' dstRoot Return: The destination root inside the BIDS structure intendedFor modalityLabel Returns: A string '_ ' srcRoot Return: The sidecar source root to move suffix The suffix to build filenames","title":"Instance variables"},{"location":"reference/dcm2bids/structure/#methods","text":"","title":"Methods"},{"location":"reference/dcm2bids/structure/#dstsidecardata","text":"def dstSidecarData ( self , descriptions ) View Source def dstSidecarData(self, descriptions): \"\"\" \"\"\" data = self.srcSidecar.origData data[\"Dcm2bidsVersion\"] = __version__ # intendedFor key if self.intendedFor != [None]: intendedValue = [] for index in self.intendedFor: intendedDesc = descriptions[index] session = self.participant.session dataType = intendedDesc[\"dataType\"] niiFile = self.participant.prefix niiFile += self.prepend(intendedDesc.get(\"customLabels\", \"\")) niiFile += self.prepend(intendedDesc[\"modalityLabel\"]) niiFile += \".nii.gz\" intendedValue.append(opj(session, dataType, niiFile).replace(\"\\\\\", \"/\")) if len(intendedValue) == 1: data[\"IntendedFor\"] = intendedValue[0] else: data[\"IntendedFor\"] = intendedValue # sidecarChanges for key, value in iteritems(self.sidecarChanges): data[key] = value return data","title":"dstSidecarData"},{"location":"reference/dcm2bids/structure/#participant","text":"class Participant ( name , session = '' )","title":"Participant"},{"location":"reference/dcm2bids/structure/#attributes_1","text":"Name Type Description Default name str Label of your participant None session str Optional label of a session None View Source class Participant(object): \"\"\" Class representing a participant Args: name (str): Label of your participant session (str): Optional label of a session \"\"\" def __init__(self, name, session=DEFAULT.session): self._name = \"\" self._session = \"\" self.name = name self.session = session @property def name(self): \"\"\" Returns: A string 'sub-<subject_label>' \"\"\" return self._name @name.setter def name(self, name): \"\"\" Prepend 'sub-' if necessary\"\"\" if name.startswith(\"sub-\"): self._name = name else: self._name = \"sub-\" + name @property def session(self): \"\"\" Returns: A string 'ses-<session_label>' \"\"\" return self._session @session.setter def session(self, session): \"\"\" Prepend 'ses-' if necessary\"\"\" if session.strip() == \"\": self._session = \"\" elif session.startswith(\"ses-\"): self._session = session else: self._session = \"ses-\" + session @property def directory(self): \"\"\" The directory of the participant Returns: A path 'sub-<subject_label>' or 'sub-<subject_label>/ses-<session_label>' \"\"\" if self.hasSession(): return opj(self.name, self.session) else: return self.name @property def prefix(self): \"\"\" The prefix to build filenames Returns: A string 'sub-<subject_label>' or 'sub-<subject_label>_ses-<session_label>' \"\"\" if self.hasSession(): return self.name + \"_\" + self.session else: return self.name def hasSession(self): \"\"\" Check if a session is set Returns: Boolean \"\"\" return self.session.strip() != DEFAULT.session","title":"Attributes"},{"location":"reference/dcm2bids/structure/#instance-variables_1","text":"directory The directory of the participant name Returns: A string 'sub- ' prefix The prefix to build filenames session Returns: A string 'ses- '","title":"Instance variables"},{"location":"reference/dcm2bids/structure/#methods_1","text":"","title":"Methods"},{"location":"reference/dcm2bids/structure/#hassession","text":"def hasSession ( self ) Check if a session is set Returns: Type Description None Boolean View Source def hasSession(self): \"\"\" Check if a session is set Returns: Boolean \"\"\" return self.session.strip() != DEFAULT.session","title":"hasSession"},{"location":"reference/dcm2bids/utils/","text":"Module dcm2bids.utils None None View Source # -*- coding: utf-8 -*- import csv import json import logging import os import shlex from collections import OrderedDict from subprocess import check_output class DEFAULT(object): \"\"\" Default values of the package\"\"\" # cli dcm2bids cliSession = \"\" cliOutputDir = os.getcwd() cliLogLevel = \"INFO\" # dcm2bids.py outputDir = cliOutputDir session = cliSession # also Participant object clobber = False forceDcm2niix = False defaceTpl = None logLevel = \"WARNING\" # dcm2niix.py dcm2niixOptions = \"-b y -ba y -z y -f '%3s_%f_%p_%t'\" dcm2niixVersion = \"v1.0.20181125\" # sidecar.py compKeys = [\"SeriesNumber\", \"AcquisitionTime\", \"SidecarFilename\"] searchMethod = \"fnmatch\" searchMethodChoices = [\"fnmatch\", \"re\"] runTpl = \"_run-{:02d}\" caseSensitive = True # misc tmpDirName = \"tmp_dcm2bids\" helperDir = \"helper\" def load_json(filename): \"\"\" Load a JSON file Args: filename (str): Path of a JSON file Return: Dictionnary of the JSON file \"\"\" with open(filename, \"r\") as f: data = json.load(f, object_pairs_hook=OrderedDict) return data def save_json(filename, data): with open(filename, \"w\") as f: json.dump(data, f, indent=4) def write_txt(filename, lines): with open(filename, \"a\") as f: for row in lines: f.write(\"%s\\n\" % row) def write_participants(filename, participants): with open(filename, \"w\") as f: writer = csv.DictWriter(f, delimiter=\"\\t\", fieldnames=participants[0].keys()) writer.writeheader() writer.writerows(participants) def read_participants(filename): if not os.path.exists(filename): return [] with open(filename, \"r\") as f: reader = csv.DictReader(f, delimiter=\"\\t\") return [row for row in reader] def splitext_(path, extensions=None): \"\"\" Split the extension from a pathname Handle case with extensions with '.' in it Args: path (str): A path to split extensions (list): List of special extensions Returns: (root, ext): ext may be empty \"\"\" if extensions is None: extensions = [\".nii.gz\"] for ext in extensions: if path.endswith(ext): return path[: -len(ext)], path[-len(ext) :] return os.path.splitext(path) def run_shell_command(commandLine): \"\"\" Wrapper of subprocess.check_output Returns: Run command with arguments and return its output \"\"\" logger = logging.getLogger(__name__) logger.info(\"Running %s\", commandLine) return check_output(shlex.split(commandLine)) Functions load_json def load_json ( filename ) Load a JSON file Args: filename (str): Path of a JSON file Return: Dictionnary of the JSON file View Source def load_json(filename): \"\"\" Load a JSON file Args: filename (str): Path of a JSON file Return: Dictionnary of the JSON file \"\"\" with open(filename, \"r\") as f: data = json.load(f, object_pairs_hook=OrderedDict) return data read_participants def read_participants ( filename ) View Source def read_participants(filename): if not os.path.exists(filename): return [] with open(filename, \"r\") as f: reader = csv.DictReader(f, delimiter=\"\\t\") return [row for row in reader] run_shell_command def run_shell_command ( commandLine ) Wrapper of subprocess.check_output Returns: Type Description None Run command with arguments and return its output View Source def run_shell_command(commandLine): \"\"\" Wrapper of subprocess.check_output Returns: Run command with arguments and return its output \"\"\" logger = logging.getLogger(__name__) logger.info(\"Running %s\", commandLine) return check_output(shlex.split(commandLine)) save_json def save_json ( filename , data ) View Source def save_json(filename, data): with open(filename, \"w\") as f: json.dump(data, f, indent=4) splitext_ def splitext_ ( path , extensions = None ) Split the extension from a pathname Handle case with extensions with '.' in it Parameters: Name Type Description Default path str A path to split None extensions list List of special extensions None Returns: Type Description None (root, ext): ext may be empty View Source def splitext_(path, extensions=None): \"\"\" Split the extension from a pathname Handle case with extensions with '.' in it Args: path (str): A path to split extensions (list): List of special extensions Returns: (root, ext): ext may be empty \"\"\" if extensions is None: extensions = [\".nii.gz\"] for ext in extensions: if path.endswith(ext): return path[: -len(ext)], path[-len(ext) :] return os.path.splitext(path) write_participants def write_participants ( filename , participants ) View Source def write_participants(filename, participants): with open(filename, \"w\") as f: writer = csv.DictWriter(f, delimiter=\"\\t\", fieldnames=participants[0].keys()) writer.writeheader() writer.writerows(participants) write_txt def write_txt ( filename , lines ) View Source def write_txt(filename, lines): with open(filename, \"a\") as f: for row in lines: f.write(\"%s\\n\" % row) Classes DEFAULT class DEFAULT ( / , * args , ** kwargs ) View Source class DEFAULT(object): \"\"\" Default values of the package\"\"\" # cli dcm2bids cliSession = \"\" cliOutputDir = os.getcwd() cliLogLevel = \"INFO\" # dcm2bids.py outputDir = cliOutputDir session = cliSession # also Participant object clobber = False forceDcm2niix = False defaceTpl = None logLevel = \"WARNING\" # dcm2niix.py dcm2niixOptions = \"-b y -ba y -z y -f '%3s_%f_%p_%t'\" dcm2niixVersion = \"v1.0.20181125\" # sidecar.py compKeys = [\"SeriesNumber\", \"AcquisitionTime\", \"SidecarFilename\"] searchMethod = \"fnmatch\" searchMethodChoices = [\"fnmatch\", \"re\"] runTpl = \"_run-{:02d}\" caseSensitive = True # misc tmpDirName = \"tmp_dcm2bids\" helperDir = \"helper\" Class variables caseSensitive cliLogLevel cliOutputDir cliSession clobber compKeys dcm2niixOptions dcm2niixVersion defaceTpl forceDcm2niix helperDir logLevel outputDir runTpl searchMethod searchMethodChoices session tmpDirName","title":"Utils"},{"location":"reference/dcm2bids/utils/#module-dcm2bidsutils","text":"None None View Source # -*- coding: utf-8 -*- import csv import json import logging import os import shlex from collections import OrderedDict from subprocess import check_output class DEFAULT(object): \"\"\" Default values of the package\"\"\" # cli dcm2bids cliSession = \"\" cliOutputDir = os.getcwd() cliLogLevel = \"INFO\" # dcm2bids.py outputDir = cliOutputDir session = cliSession # also Participant object clobber = False forceDcm2niix = False defaceTpl = None logLevel = \"WARNING\" # dcm2niix.py dcm2niixOptions = \"-b y -ba y -z y -f '%3s_%f_%p_%t'\" dcm2niixVersion = \"v1.0.20181125\" # sidecar.py compKeys = [\"SeriesNumber\", \"AcquisitionTime\", \"SidecarFilename\"] searchMethod = \"fnmatch\" searchMethodChoices = [\"fnmatch\", \"re\"] runTpl = \"_run-{:02d}\" caseSensitive = True # misc tmpDirName = \"tmp_dcm2bids\" helperDir = \"helper\" def load_json(filename): \"\"\" Load a JSON file Args: filename (str): Path of a JSON file Return: Dictionnary of the JSON file \"\"\" with open(filename, \"r\") as f: data = json.load(f, object_pairs_hook=OrderedDict) return data def save_json(filename, data): with open(filename, \"w\") as f: json.dump(data, f, indent=4) def write_txt(filename, lines): with open(filename, \"a\") as f: for row in lines: f.write(\"%s\\n\" % row) def write_participants(filename, participants): with open(filename, \"w\") as f: writer = csv.DictWriter(f, delimiter=\"\\t\", fieldnames=participants[0].keys()) writer.writeheader() writer.writerows(participants) def read_participants(filename): if not os.path.exists(filename): return [] with open(filename, \"r\") as f: reader = csv.DictReader(f, delimiter=\"\\t\") return [row for row in reader] def splitext_(path, extensions=None): \"\"\" Split the extension from a pathname Handle case with extensions with '.' in it Args: path (str): A path to split extensions (list): List of special extensions Returns: (root, ext): ext may be empty \"\"\" if extensions is None: extensions = [\".nii.gz\"] for ext in extensions: if path.endswith(ext): return path[: -len(ext)], path[-len(ext) :] return os.path.splitext(path) def run_shell_command(commandLine): \"\"\" Wrapper of subprocess.check_output Returns: Run command with arguments and return its output \"\"\" logger = logging.getLogger(__name__) logger.info(\"Running %s\", commandLine) return check_output(shlex.split(commandLine))","title":"Module dcm2bids.utils"},{"location":"reference/dcm2bids/utils/#functions","text":"","title":"Functions"},{"location":"reference/dcm2bids/utils/#load_json","text":"def load_json ( filename ) Load a JSON file Args: filename (str): Path of a JSON file Return: Dictionnary of the JSON file View Source def load_json(filename): \"\"\" Load a JSON file Args: filename (str): Path of a JSON file Return: Dictionnary of the JSON file \"\"\" with open(filename, \"r\") as f: data = json.load(f, object_pairs_hook=OrderedDict) return data","title":"load_json"},{"location":"reference/dcm2bids/utils/#read_participants","text":"def read_participants ( filename ) View Source def read_participants(filename): if not os.path.exists(filename): return [] with open(filename, \"r\") as f: reader = csv.DictReader(f, delimiter=\"\\t\") return [row for row in reader]","title":"read_participants"},{"location":"reference/dcm2bids/utils/#run_shell_command","text":"def run_shell_command ( commandLine ) Wrapper of subprocess.check_output Returns: Type Description None Run command with arguments and return its output View Source def run_shell_command(commandLine): \"\"\" Wrapper of subprocess.check_output Returns: Run command with arguments and return its output \"\"\" logger = logging.getLogger(__name__) logger.info(\"Running %s\", commandLine) return check_output(shlex.split(commandLine))","title":"run_shell_command"},{"location":"reference/dcm2bids/utils/#save_json","text":"def save_json ( filename , data ) View Source def save_json(filename, data): with open(filename, \"w\") as f: json.dump(data, f, indent=4)","title":"save_json"},{"location":"reference/dcm2bids/utils/#splitext_","text":"def splitext_ ( path , extensions = None ) Split the extension from a pathname Handle case with extensions with '.' in it Parameters: Name Type Description Default path str A path to split None extensions list List of special extensions None Returns: Type Description None (root, ext): ext may be empty View Source def splitext_(path, extensions=None): \"\"\" Split the extension from a pathname Handle case with extensions with '.' in it Args: path (str): A path to split extensions (list): List of special extensions Returns: (root, ext): ext may be empty \"\"\" if extensions is None: extensions = [\".nii.gz\"] for ext in extensions: if path.endswith(ext): return path[: -len(ext)], path[-len(ext) :] return os.path.splitext(path)","title":"splitext_"},{"location":"reference/dcm2bids/utils/#write_participants","text":"def write_participants ( filename , participants ) View Source def write_participants(filename, participants): with open(filename, \"w\") as f: writer = csv.DictWriter(f, delimiter=\"\\t\", fieldnames=participants[0].keys()) writer.writeheader() writer.writerows(participants)","title":"write_participants"},{"location":"reference/dcm2bids/utils/#write_txt","text":"def write_txt ( filename , lines ) View Source def write_txt(filename, lines): with open(filename, \"a\") as f: for row in lines: f.write(\"%s\\n\" % row)","title":"write_txt"},{"location":"reference/dcm2bids/utils/#classes","text":"","title":"Classes"},{"location":"reference/dcm2bids/utils/#default","text":"class DEFAULT ( / , * args , ** kwargs ) View Source class DEFAULT(object): \"\"\" Default values of the package\"\"\" # cli dcm2bids cliSession = \"\" cliOutputDir = os.getcwd() cliLogLevel = \"INFO\" # dcm2bids.py outputDir = cliOutputDir session = cliSession # also Participant object clobber = False forceDcm2niix = False defaceTpl = None logLevel = \"WARNING\" # dcm2niix.py dcm2niixOptions = \"-b y -ba y -z y -f '%3s_%f_%p_%t'\" dcm2niixVersion = \"v1.0.20181125\" # sidecar.py compKeys = [\"SeriesNumber\", \"AcquisitionTime\", \"SidecarFilename\"] searchMethod = \"fnmatch\" searchMethodChoices = [\"fnmatch\", \"re\"] runTpl = \"_run-{:02d}\" caseSensitive = True # misc tmpDirName = \"tmp_dcm2bids\" helperDir = \"helper\"","title":"DEFAULT"},{"location":"reference/dcm2bids/utils/#class-variables","text":"caseSensitive cliLogLevel cliOutputDir cliSession clobber compKeys dcm2niixOptions dcm2niixVersion defaceTpl forceDcm2niix helperDir logLevel outputDir runTpl searchMethod searchMethodChoices session tmpDirName","title":"Class variables"},{"location":"reference/dcm2bids/version/","text":"Module dcm2bids.version This module take care of the versioning None View Source # -*- coding: utf-8 -*- \"\"\"This module take care of the versioning\"\"\" # dcm2bids version __version__ = \"2.1.6\" import logging import shlex import socket from distutils.version import LooseVersion from subprocess import check_output from shutil import which logger = logging.getLogger(__name__) def internet(host=\"8.8.8.8\", port=53, timeout=3): \"\"\" Check if user has internet Args: host (string): 8.8.8.8 (google-public-dns-a.google.com) port (int): OpenPort 53/tcp Service: domain (DNS/TCP) timeout (int): default=3 Returns: boolean Source: https://stackoverflow.com/a/33117579 \"\"\" try: socket.setdefaulttimeout(timeout) socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect((host, port)) return True except: return False def is_tool(name): \"\"\" Check if a program is in PATH Args: name (string): program name Returns: boolean \"\"\" return which(name) is not None def check_github_latest(githubRepo): \"\"\" Check the latest version of a github repository Args: githubRepo (string): a github repository (\"username/repository\") Returns: A string of the version \"\"\" url = \"https://github.com/{}/releases/latest\".format(githubRepo) try: output = check_output(shlex.split(\"curl --silent \" + url)) except: logger.debug( \"Checking latest version of %s was not possible\", githubRepo, exc_info=True, ) return # The output should have this format # <html><body>You are being <a href=\"https://github.com/{gitRepo}/releases/tag/{version}\">redirected</a>.</body></html> try: return ( output.decode() .split(\"{}/releases/tag/\".format(githubRepo))[1] .split('\"')[0] ) except: logger.debug( \"Checking latest version of %s was not possible\", githubRepo, exc_info=True, ) return def check_latest(name=\"dcm2bids\"): \"\"\" Check if a new version of a software exists and print some details Implemented for dcm2bids, dcm2niix Args: name (string): name of the software Returns: None \"\"\" data = { \"dcm2bids\": { \"repo\": \"unfmontreal/Dcm2Bids\", \"host\": \"https://github.com\", \"current\": __version__, }, \"dcm2niix\": { \"repo\": \"rordenlab/dcm2niix\", \"host\": \"https://github.com\", \"current\": dcm2niix_version, }, } if internet() and is_tool(\"curl\"): host = data.get(name)[\"host\"] if host == \"https://github.com\": repo = data.get(name)[\"repo\"] latest = check_github_latest(repo) else: # Not implemented return else: logger.debug(\"Checking latest version of %s was not possible\", name) logger.debug(\"internet: %s, curl: %s\", internet(), is_tool(\"curl\")) return current = data.get(name)[\"current\"] if callable(current): current = current() try: news = LooseVersion(latest) > LooseVersion(current) except: news = None if news: logger.warning(\"Your using %s version %s\", name, current) logger.warning(\"A new version exists : %s\", latest) logger.warning(\"Check %s/%s\", host, repo) def dcm2niix_version(): \"\"\" Returns: A string of the version of dcm2niix install on the system \"\"\" if not is_tool(\"dcm2niix\"): logger.error(\"dcm2niix is not in your PATH or not installed\") logger.error(\"Check https://github.com/rordenlab/dcm2niix\") return try: output = check_output(shlex.split(\"dcm2niix\")) except: logger.error(\"Running: dcm2niix\", exc_info=True) return try: lines = output.decode().split(\"\\n\") except: logger.debug(output, exc_info=True) return for line in lines: try: splits = line.split() return splits[splits.index(\"version\") + 1] except: continue return Variables logger Functions check_github_latest def check_github_latest ( githubRepo ) Check the latest version of a github repository Parameters: Name Type Description Default githubRepo string a github repository (\"username/repository\") None Returns: Type Description None A string of the version View Source def check_github_latest(githubRepo): \"\"\" Check the latest version of a github repository Args: githubRepo (string): a github repository (\"username/repository\") Returns: A string of the version \"\"\" url = \"https://github.com/{}/releases/latest\".format(githubRepo) try: output = check_output(shlex.split(\"curl --silent \" + url)) except: logger.debug( \"Checking latest version of %s was not possible\", githubRepo, exc_info=True, ) return # The output should have this format # <html><body>You are being <a href=\"https://github.com/{gitRepo}/releases/tag/{version}\">redirected</a>.</body></html> try: return ( output.decode() .split(\"{}/releases/tag/\".format(githubRepo))[1] .split('\"')[0] ) except: logger.debug( \"Checking latest version of %s was not possible\", githubRepo, exc_info=True, ) return check_latest def check_latest ( name = 'dcm2bids' ) Check if a new version of a software exists and print some details Implemented for dcm2bids, dcm2niix Parameters: Name Type Description Default name string name of the software None Returns: Type Description None None View Source def check_latest(name=\"dcm2bids\"): \"\"\" Check if a new version of a software exists and print some details Implemented for dcm2bids, dcm2niix Args: name (string): name of the software Returns: None \"\"\" data = { \"dcm2bids\": { \"repo\": \"unfmontreal/Dcm2Bids\", \"host\": \"https://github.com\", \"current\": __version__, }, \"dcm2niix\": { \"repo\": \"rordenlab/dcm2niix\", \"host\": \"https://github.com\", \"current\": dcm2niix_version, }, } if internet() and is_tool(\"curl\"): host = data.get(name)[\"host\"] if host == \"https://github.com\": repo = data.get(name)[\"repo\"] latest = check_github_latest(repo) else: # Not implemented return else: logger.debug(\"Checking latest version of %s was not possible\", name) logger.debug(\"internet: %s, curl: %s\", internet(), is_tool(\"curl\")) return current = data.get(name)[\"current\"] if callable(current): current = current() try: news = LooseVersion(latest) > LooseVersion(current) except: news = None if news: logger.warning(\"Your using %s version %s\", name, current) logger.warning(\"A new version exists : %s\", latest) logger.warning(\"Check %s/%s\", host, repo) dcm2niix_version def dcm2niix_version ( ) Returns: A string of the version of dcm2niix install on the system View Source def dcm2niix_version(): \"\"\" Returns: A string of the version of dcm2niix install on the system \"\"\" if not is_tool(\"dcm2niix\"): logger.error(\"dcm2niix is not in your PATH or not installed\") logger.error(\"Check https://github.com/rordenlab/dcm2niix\") return try: output = check_output(shlex.split(\"dcm2niix\")) except: logger.error(\"Running: dcm2niix\", exc_info=True) return try: lines = output.decode().split(\"\\n\") except: logger.debug(output, exc_info=True) return for line in lines: try: splits = line.split() return splits[splits.index(\"version\") + 1] except: continue return internet def internet ( host = '8.8.8.8' , port = 53 , timeout = 3 ) Check if user has internet Parameters: Name Type Description Default host string 8.8.8.8 (google-public-dns-a.google.com) None port int OpenPort 53/tcp Service: domain (DNS/TCP) None timeout int default=3 None Returns: Type Description None boolean Source: https://stackoverflow.com/a/33117579 | View Source def internet(host=\"8.8.8.8\", port=53, timeout=3): \"\"\" Check if user has internet Args: host (string): 8.8.8.8 (google-public-dns-a.google.com) port (int): OpenPort 53/tcp Service: domain (DNS/TCP) timeout (int): default=3 Returns: boolean Source: https://stackoverflow.com/a/33117579 \"\"\" try: socket.setdefaulttimeout(timeout) socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect((host, port)) return True except: return False is_tool def is_tool ( name ) Check if a program is in PATH Parameters: Name Type Description Default name string program name None Returns: Type Description None boolean View Source def is_tool(name): \"\"\" Check if a program is in PATH Args: name (string): program name Returns: boolean \"\"\" return which(name) is not None","title":"Version"},{"location":"reference/dcm2bids/version/#module-dcm2bidsversion","text":"This module take care of the versioning None View Source # -*- coding: utf-8 -*- \"\"\"This module take care of the versioning\"\"\" # dcm2bids version __version__ = \"2.1.6\" import logging import shlex import socket from distutils.version import LooseVersion from subprocess import check_output from shutil import which logger = logging.getLogger(__name__) def internet(host=\"8.8.8.8\", port=53, timeout=3): \"\"\" Check if user has internet Args: host (string): 8.8.8.8 (google-public-dns-a.google.com) port (int): OpenPort 53/tcp Service: domain (DNS/TCP) timeout (int): default=3 Returns: boolean Source: https://stackoverflow.com/a/33117579 \"\"\" try: socket.setdefaulttimeout(timeout) socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect((host, port)) return True except: return False def is_tool(name): \"\"\" Check if a program is in PATH Args: name (string): program name Returns: boolean \"\"\" return which(name) is not None def check_github_latest(githubRepo): \"\"\" Check the latest version of a github repository Args: githubRepo (string): a github repository (\"username/repository\") Returns: A string of the version \"\"\" url = \"https://github.com/{}/releases/latest\".format(githubRepo) try: output = check_output(shlex.split(\"curl --silent \" + url)) except: logger.debug( \"Checking latest version of %s was not possible\", githubRepo, exc_info=True, ) return # The output should have this format # <html><body>You are being <a href=\"https://github.com/{gitRepo}/releases/tag/{version}\">redirected</a>.</body></html> try: return ( output.decode() .split(\"{}/releases/tag/\".format(githubRepo))[1] .split('\"')[0] ) except: logger.debug( \"Checking latest version of %s was not possible\", githubRepo, exc_info=True, ) return def check_latest(name=\"dcm2bids\"): \"\"\" Check if a new version of a software exists and print some details Implemented for dcm2bids, dcm2niix Args: name (string): name of the software Returns: None \"\"\" data = { \"dcm2bids\": { \"repo\": \"unfmontreal/Dcm2Bids\", \"host\": \"https://github.com\", \"current\": __version__, }, \"dcm2niix\": { \"repo\": \"rordenlab/dcm2niix\", \"host\": \"https://github.com\", \"current\": dcm2niix_version, }, } if internet() and is_tool(\"curl\"): host = data.get(name)[\"host\"] if host == \"https://github.com\": repo = data.get(name)[\"repo\"] latest = check_github_latest(repo) else: # Not implemented return else: logger.debug(\"Checking latest version of %s was not possible\", name) logger.debug(\"internet: %s, curl: %s\", internet(), is_tool(\"curl\")) return current = data.get(name)[\"current\"] if callable(current): current = current() try: news = LooseVersion(latest) > LooseVersion(current) except: news = None if news: logger.warning(\"Your using %s version %s\", name, current) logger.warning(\"A new version exists : %s\", latest) logger.warning(\"Check %s/%s\", host, repo) def dcm2niix_version(): \"\"\" Returns: A string of the version of dcm2niix install on the system \"\"\" if not is_tool(\"dcm2niix\"): logger.error(\"dcm2niix is not in your PATH or not installed\") logger.error(\"Check https://github.com/rordenlab/dcm2niix\") return try: output = check_output(shlex.split(\"dcm2niix\")) except: logger.error(\"Running: dcm2niix\", exc_info=True) return try: lines = output.decode().split(\"\\n\") except: logger.debug(output, exc_info=True) return for line in lines: try: splits = line.split() return splits[splits.index(\"version\") + 1] except: continue return","title":"Module dcm2bids.version"},{"location":"reference/dcm2bids/version/#variables","text":"logger","title":"Variables"},{"location":"reference/dcm2bids/version/#functions","text":"","title":"Functions"},{"location":"reference/dcm2bids/version/#check_github_latest","text":"def check_github_latest ( githubRepo ) Check the latest version of a github repository Parameters: Name Type Description Default githubRepo string a github repository (\"username/repository\") None Returns: Type Description None A string of the version View Source def check_github_latest(githubRepo): \"\"\" Check the latest version of a github repository Args: githubRepo (string): a github repository (\"username/repository\") Returns: A string of the version \"\"\" url = \"https://github.com/{}/releases/latest\".format(githubRepo) try: output = check_output(shlex.split(\"curl --silent \" + url)) except: logger.debug( \"Checking latest version of %s was not possible\", githubRepo, exc_info=True, ) return # The output should have this format # <html><body>You are being <a href=\"https://github.com/{gitRepo}/releases/tag/{version}\">redirected</a>.</body></html> try: return ( output.decode() .split(\"{}/releases/tag/\".format(githubRepo))[1] .split('\"')[0] ) except: logger.debug( \"Checking latest version of %s was not possible\", githubRepo, exc_info=True, ) return","title":"check_github_latest"},{"location":"reference/dcm2bids/version/#check_latest","text":"def check_latest ( name = 'dcm2bids' ) Check if a new version of a software exists and print some details Implemented for dcm2bids, dcm2niix Parameters: Name Type Description Default name string name of the software None Returns: Type Description None None View Source def check_latest(name=\"dcm2bids\"): \"\"\" Check if a new version of a software exists and print some details Implemented for dcm2bids, dcm2niix Args: name (string): name of the software Returns: None \"\"\" data = { \"dcm2bids\": { \"repo\": \"unfmontreal/Dcm2Bids\", \"host\": \"https://github.com\", \"current\": __version__, }, \"dcm2niix\": { \"repo\": \"rordenlab/dcm2niix\", \"host\": \"https://github.com\", \"current\": dcm2niix_version, }, } if internet() and is_tool(\"curl\"): host = data.get(name)[\"host\"] if host == \"https://github.com\": repo = data.get(name)[\"repo\"] latest = check_github_latest(repo) else: # Not implemented return else: logger.debug(\"Checking latest version of %s was not possible\", name) logger.debug(\"internet: %s, curl: %s\", internet(), is_tool(\"curl\")) return current = data.get(name)[\"current\"] if callable(current): current = current() try: news = LooseVersion(latest) > LooseVersion(current) except: news = None if news: logger.warning(\"Your using %s version %s\", name, current) logger.warning(\"A new version exists : %s\", latest) logger.warning(\"Check %s/%s\", host, repo)","title":"check_latest"},{"location":"reference/dcm2bids/version/#dcm2niix_version","text":"def dcm2niix_version ( ) Returns: A string of the version of dcm2niix install on the system View Source def dcm2niix_version(): \"\"\" Returns: A string of the version of dcm2niix install on the system \"\"\" if not is_tool(\"dcm2niix\"): logger.error(\"dcm2niix is not in your PATH or not installed\") logger.error(\"Check https://github.com/rordenlab/dcm2niix\") return try: output = check_output(shlex.split(\"dcm2niix\")) except: logger.error(\"Running: dcm2niix\", exc_info=True) return try: lines = output.decode().split(\"\\n\") except: logger.debug(output, exc_info=True) return for line in lines: try: splits = line.split() return splits[splits.index(\"version\") + 1] except: continue return","title":"dcm2niix_version"},{"location":"reference/dcm2bids/version/#internet","text":"def internet ( host = '8.8.8.8' , port = 53 , timeout = 3 ) Check if user has internet Parameters: Name Type Description Default host string 8.8.8.8 (google-public-dns-a.google.com) None port int OpenPort 53/tcp Service: domain (DNS/TCP) None timeout int default=3 None Returns: Type Description None boolean Source: https://stackoverflow.com/a/33117579 | View Source def internet(host=\"8.8.8.8\", port=53, timeout=3): \"\"\" Check if user has internet Args: host (string): 8.8.8.8 (google-public-dns-a.google.com) port (int): OpenPort 53/tcp Service: domain (DNS/TCP) timeout (int): default=3 Returns: boolean Source: https://stackoverflow.com/a/33117579 \"\"\" try: socket.setdefaulttimeout(timeout) socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect((host, port)) return True except: return False","title":"internet"},{"location":"reference/dcm2bids/version/#is_tool","text":"def is_tool ( name ) Check if a program is in PATH Parameters: Name Type Description Default name string program name None Returns: Type Description None boolean View Source def is_tool(name): \"\"\" Check if a program is in PATH Args: name (string): program name Returns: boolean \"\"\" return which(name) is not None","title":"is_tool"}]}